\input texinfo.tex
@c %**start of header
@setfilename vicare-openssl.info
@settitle Openssl for Vicare
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Openssl for Vicare

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Vicare/@openssl{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           vicare-openssl

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi.ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2013

@c ------------------------------------------------------------

@set FOREIGN_PACKAGE            @openssl{}
@set FOREIGN_VERSION            1.0.1e
@set FOREIGN_URL                @url{http://www.openssl.org/}
@set FOREIGN_SCHEME_LIB         @library{vicare crypto openssl}
@set GITHUB_URL                 @url{http://github.com/marcomaggi/vicare-openssl}
@set DOWNLOAD_URL               @url{http://code.google.com/p/vicare-scheme/downloads/list}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.com/docs/vicare-openssl.html}


@macro opensslref{NODE, TITLE}
@xref{\NODE\,\TITLE\,\TITLE\,openssl}
@end macro

@macro openssl{}
@acronym{OpenSSL}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @version{} of @value{PACKAGE}, a
distribution of C and Scheme libraries for Vicare Scheme, an @rnrs{6}
compliant Scheme implementation; it provides bindings for the
@value{FOREIGN_PACKAGE} C language library.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
@value{FOREIGN_PACKAGE} is available at:

@center @value{FOREIGN_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* vicare-openssl: (vicare-openssl). @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Openssl version informations.
* plain::                       Plain programming interface.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


Vicare Scheme is an @rnrs{6} compliant Scheme language implementation in
the form of a native compiler for x86 architectures, officially
supporting @gnu{}+Linux systems.  @value{PACKAGE} is a distribution of C
language and Scheme language libraries for Vicare Scheme; it provides
bindings for the @value{FOREIGN_PACKAGE} C language library.

The last time the author bothered to update this paragraph, he had
tested @value{FOREIGN_PACKAGE} version @value{FOREIGN_VERSION}; This
product includes software developed by the OpenSSL Project for use in
the OpenSSL Toolkit.  (@url{http://www.openssl.org/})

The package installs a C language library implementing wrapper C
functions for the C language @value{FOREIGN_PACKAGE} library; on top of
this, the Scheme library @library{vicare crypto openssl} exports one
binding for some @value{FOREIGN_PACKAGE} public functions; additionally
the library @library{vicare crypto openssl constants} exports one
binding for some constant values defined in the C language header
@file{openssl/ssl.h} and others.

Most of the Scheme function names are directly derived from the C
function names by replacing upper case with lower case and underscore
characters @samp{_} with dash characters @samp{-}; so
@cfunc{SSL_library_init} becomes @func{ssl-library-init}.  In some rare
case a dash is inserted to make the name more readable, for example
@cfunc{EVP_DigestInit} becomes @func{evp-digest-init}.

The following Scheme libraries are installed:

@table @library
@item vicare crypto openssl
@cindex Library @library{vicare crypto openssl}
@cindex @library{vicare crypto openssl}, library
It exports bindings for some @value{FOREIGN_PACKAGE} core public
functions needed for library initialisation.

@item vicare crypto openssl evp message-digests
@cindex Library @library{vicare crypto openssl evp message-digests}
@cindex @library{vicare crypto openssl evp message-digests}, library
It exports bindings for some @value{FOREIGN_PACKAGE} high--level
functions implementing the EVP message digests @api{}.

@item vicare crypto openssl evp ciphers
@cindex Library @library{vicare crypto openssl evp ciphers}
@cindex @library{vicare crypto openssl evp ciphers}, library
It exports bindings for some @value{FOREIGN_PACKAGE} high--level
functions implementing the EVP ciphers @api{}.

@item vicare crypto openssl message-digests
@cindex Library @library{vicare crypto openssl message-digests}
@cindex @library{vicare crypto openssl message-digests}, library
It exports bindings for some @value{FOREIGN_PACKAGE} low--level
functions implementing message digests.

@item vicare crypto openssl hmac
@cindex Library @library{vicare crypto openssl hmac}
@cindex @library{vicare crypto openssl hmac}, library
It exports bindings for some @value{FOREIGN_PACKAGE} low--level
functions implementing HMAC.

@item vicare crypto openssl aes
@cindex Library @library{vicare crypto openssl aes}
@cindex @library{vicare crypto openssl aes}, library
It exports bindings for some @value{FOREIGN_PACKAGE} low--level
functions implementing the AES cipher.

@item vicare crypto openssl unsafe-capi
@cindex Library @library{vicare crypto openssl unsafe-capi}
@cindex @library{vicare crypto openssl unsafe-capi}, library
It exports syntax bindings for some @value{FOREIGN_PACKAGE} public
functions.  These syntaxes expand to a direct call to the C language
wrapper functions in the @value{PACKAGE} library; they are not meant to
be called in normal usage of the package.

@item vicare crypto openssl constants
@cindex Library @library{vicare crypto openssl constants}
@cindex @library{vicare crypto openssl constants}, library
It exports bindings for some constant values defined in the C language
header @file{openssl/ssl.h} and others.

@item vicare crypto openssl features
@cindex Library @library{vicare crypto openssl features}
@cindex @library{vicare crypto openssl features}, library
It exports one identifier syntax binding for each @code{HAVE_} constant
defined by the @command{configure} script, expanding to @true{} or
@false{}.
@end table

Scheme libraries are installed under the directory:

@center @file{$(libdir)/vicare-scheme}

After installation, under the directory:

@center @file{$(libexecdir)/@value{PACKAGE_NICKNAME}}

@noindent
a script @file{compile-all.sps} can be executed to precompile the
installed libraries; for example:

@example
$ sudo vicare \
   --fasl-directory /var/cache/vicare-scheme \
   --compile-dependencies \
      /usr/local/libexec/vicare-openssl/compile-all.sps
@end example

This document contains only a brief description of the functions: refer
to the @value{FOREIGN_PACKAGE}'s documentation for details.

@c page
@node version
@chapter @value{FOREIGN_PACKAGE} version informations


The installed C library follows version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.

The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun vicare-openssl-version-interface-current
@defunx vicare-openssl-version-interface-revision
@defunx vicare-openssl-version-interface-age
Return a fixnum representing a version number.
@end defun


@defun vicare-openssl-version
Return a Scheme string representing the version number.
@end defun

@c page
@node plain
@chapter Plain programming interface


@menu
* plain init::                  Global initialisation functions.
* plain hash::                  Computing hash checksums.
* plain hmac::                  Computing message authentication codes.
* plain crypto::                Low-level cryptographic algorithms.
* plain evp::                   High-level cryptographic functions.
@end menu

@c page
@node plain init
@section Global initialisation functions


The following bindings are exported by the library @library{vicare
crypto openssl}.


@defun ssl-library-init
Initialise the library; return unspecified values.
@manpage{SSL_library_init, SSL_library_init}.
@end defun


@defun openssl-add-all-algorithms-noconf
Perform some initialisation operations.
@manpage{OPENSSL_add_all_algorithms_noconf, OPENSSL_add_all_algorithms_noconf}.
@end defun


@defun openssl-add-all-algorithms-conf
Perform some initialisation operations.
@manpage{OPENSSL_add_all_algorithms_conf, OPENSSL_add_all_algorithms_conf}.
@end defun


@defun openssl-add-all-algorithms
Perform some initialisation operations.
@manpage{OpenSSL_add_all_algorithms, OpenSSL_add_all_algorithms}.
@end defun


@defun openssl-add-all-ciphers
Perform some initialisation operations.
@manpage{OpenSSL_add_all_ciphers, OpenSSL_add_all_ciphers}.
@end defun


@defun openssl-add-all-digests
Perform some initialisation operations.
@manpage{OpenSSL_add_all_digests, OpenSSL_add_all_digests}.
@end defun


@defun ssleay-add-all-algorithms
Perform some initialisation operations.
@manpage{SSLeay_add_all_algorithms, SSLeay_add_all_algorithms}.
@end defun


@defun ssleay-add-all-ciphers
Perform some initialisation operations.
@manpage{SSLeay_add_all_ciphers, SSLeay_add_all_ciphers}.
@end defun


@defun ssleay-add-all-digests
Perform some initialisation operations.
@manpage{SSLeay_add_all_digests, SSLeay_add_all_digests}.
@end defun

@c page
@node plain hash
@section Computing hash checksums


@menu
* plain hash md4::              Computing MD4 hash checksums.
* plain hash md5::              Computing MD5 hash checksums.
* plain hash mdc2::             Computing MDC2 hash checksums.
* plain hash sha1::             Computing SHA1 hash checksums.
* plain hash sha224::           Computing SHA224 hash checksums.
* plain hash sha256::           Computing SHA256 hash checksums.
* plain hash sha384::           Computing SHA384 hash checksums.
* plain hash sha512::           Computing SHA512 hash checksums.
* plain hash ripemd160::        Computing RIPEMD160 hash checksums.
* plain hash whirlpool::        Computing WHIRLPOOL hash checksums.
@end menu

@c page
@node plain hash md4
@subsection Computing MD4 hash checksums


@menu
* plain hash md4 struct::       Hash checksum data structures.
* plain hash md4 api::          Context updating functions.
* plain hash md4 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash md4 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} md4-ctx
@cindex @var{MD4} argument
@cindex Argument @var{MD4}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{MD4_CTX}; it references an MD4 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{MD4}.

There are two categories of @code{md4-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{md4-ctx} instances returned by @func{md4-init} do own the context.
When instances of this category are garbage collected or when
@func{md5-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun md4-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{md4-ctx}; otherwise
return @false{}.
@end defun


@defun md4-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{md4-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun md4-ctx-custom-destructor @var{MD4}
@defunx set-md4-ctx-custom-destructor! @var{MD4} @var{func}
Retrieve or set a destructor function associated to the @var{MD4}.

Whenever the @var{MD4} is closed, either explicitly with
@func{md4-final} or implicitly by the garbage collector, @var{func} is
applied to @var{MD4} before the internal state of @var{MD4} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{MD4}; if we do:

@example
(define context ...)
(set-md4-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((md4-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{MD4}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} md4-ctx @var{obj}
@deffnx {Validation Clause} false-or-md4-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{md4-ctx?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} md4-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-md4-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{md4-ctx?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain hash md4 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun md4-init
Allocate and initialise a new instance of @code{md4-ctx}; if successful
return the struct, else return @false{}.  @manpage{MD4_Init, MD4_Init}
@end defun


@defun md4-final @var{MD4}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{MD4_Final,
MD4_Final}.  It is fine to apply this function multiple times to the
same @var{MD4} argument.
@end defun


@defun md4-update @var{MD4} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{MD4_Update, MD4_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash md4 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun md4 @var{input}
@defunx md4 @var{input} @var{input.len}
Perform a one--step checksum computing; return a bytevector holding the
result.  @manpage{MD4, MD4}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash md5
@subsection Computing MD5 hash checksums


@menu
* plain hash md5 struct::       Hash checksum data structures.
* plain hash md5 api::          Context updating functions.
* plain hash md5 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash md5 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} md5-ctx
@cindex @var{MD5} argument
@cindex Argument @var{MD5}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{MD5_CTX}; it references an MD5 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{MD5}.

There are two categories of @code{md5-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{md5-ctx} instances returned by @func{md5-init} do own the context.
When instances of this category are garbage collected or when
@func{md5-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun md5-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{md5-ctx}; otherwise
return @false{}.
@end defun


@defun md5-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{md5-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun md5-ctx-custom-destructor @var{MD5}
@defunx set-md5-ctx-custom-destructor! @var{MD5} @var{func}
Retrieve or set a destructor function associated to the @var{MD5}.

Whenever the @var{MD5} is closed, either explicitly with
@func{md5-final} or implicitly by the garbage collector, @var{func} is
applied to @var{MD5} before the internal state of @var{MD5} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{MD5}; if we do:

@example
(define context ...)
(set-md5-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((md5-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{MD5}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} md5-ctx @var{obj}
@deffnx {Validation Clause} false-or-md5-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{md5-ctx?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} md5-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-md5-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{md5-ctx?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain hash md5 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun md5-init
Allocate and initialise a new instance of @code{md5-ctx}; if successful
return the struct, else return @false{}.  @manpage{MD5_Init, MD5_Init}
@end defun


@defun md5-final @var{MD5}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{MD5_Final,
MD5_Final}.  It is fine to apply this function multiple times to the
same @var{MD5} argument.
@end defun


@defun md5-update @var{MD5} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{MD5_Update, MD5_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash md5 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun md5 @var{input}
@defunx md5 @var{input} @var{input.len}
Perform a one--step checksum computing; return a bytevector holding the
result.  @manpage{MD5, MD5}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash mdc2
@subsection Computing MDC2 hash checksums


@menu
* plain hash mdc2 struct::       Hash checksum data structures.
* plain hash mdc2 api::          Context updating functions.
* plain hash mdc2 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash mdc2 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} mdc2-ctx
@cindex @var{MDC2} argument
@cindex Argument @var{MDC2}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{MDC2_CTX}; it references an MDC2 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{MDC2}.

There are two categories of @code{mdc2-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{mdc2-ctx} instances returned by @func{mdc2-init} do own the context.
When instances of this category are garbage collected or when
@func{mdc2-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun mdc2-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{mdc2-ctx}; otherwise
return @false{}.
@end defun


@defun mdc2-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{mdc2-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun mdc2-ctx-custom-destructor @var{MDC2}
@defunx set-mdc2-ctx-custom-destructor! @var{MDC2} @var{func}
Retrieve or set a destructor function associated to the @var{MDC2}.

Whenever the @var{MDC2} is closed, either explicitly with
@func{mdc2-final} or implicitly by the garbage collector, @var{func} is
applied to @var{MDC2} before the internal state of @var{MDC2} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{MDC2}; if we do:

@example
(define context ...)
(set-mdc2-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((mdc2-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{MDC2}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} mdc2-ctx @var{obj}
@deffnx {Validation Clause} false-or-mdc2-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{mdc2-ctx?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} mdc2-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-mdc2-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{mdc2-ctx?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain hash mdc2 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun mdc2-init
Allocate and initialise a new instance of @code{mdc2-ctx}; if successful
return the struct, else return @false{}.  @manpage{MDC2_Init, MDC2_Init}
@end defun


@defun mdc2-final @var{MDC2}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{MDC2_Final,
MDC2_Final}.  It is fine to apply this function multiple times to the
same @var{MDC2} argument.
@end defun


@defun mdc2-update @var{MDC2} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{MDC2_Update, MDC2_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash mdc2 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun mdc2 @var{input}
@defunx mdc2 @var{input} @var{input.len}
Perform a one--step checksum computing; return a bytevector holding the
result.  @manpage{MDC2, MDC2}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha1
@subsection Computing SHA1 hash checksums


@menu
* plain hash sha1 struct::       Hash checksum data structures.
* plain hash sha1 api::          Context updating functions.
* plain hash sha1 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash sha1 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} sha1-ctx
@cindex @var{SHA1} argument
@cindex Argument @var{SHA1}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{SHA1_CTX}; it references an SHA1 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{SHA1}.

There are two categories of @code{sha1-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{sha1-ctx} instances returned by @func{sha1-init} do own the context.
When instances of this category are garbage collected or when
@func{md5-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun sha1-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{sha1-ctx}; otherwise
return @false{}.
@end defun


@defun sha1-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{sha1-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun sha1-ctx-custom-destructor @var{SHA1}
@defunx set-sha1-ctx-custom-destructor! @var{SHA1} @var{func}
Retrieve or set a destructor function associated to the @var{SHA1}.

Whenever the @var{SHA1} is closed, either explicitly with
@func{sha1-final} or implicitly by the garbage collector, @var{func} is
applied to @var{SHA1} before the internal state of @var{SHA1} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{SHA1}; if we do:

@example
(define context ...)
(set-sha1-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((sha1-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{SHA1}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} sha1-ctx @var{obj}
@deffnx {Validation Clause} false-or-sha1-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{sha1-ctx?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} sha1-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-sha1-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{sha1-ctx?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain hash sha1 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha1-init
Allocate and initialise a new instance of @code{sha1-ctx}; if successful
return the struct, else return @false{}.  @manpage{SHA1_Init, SHA1_Init}
@end defun


@defun sha1-final @var{SHA1}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{SHA1_Final,
SHA1_Final}.  It is fine to apply this function multiple times to the
same @var{SHA1} argument.
@end defun


@defun sha1-update @var{SHA1} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{SHA1_Update, SHA1_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha1 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha1 @var{input}
@defunx sha1 @var{input} @var{input.len}
Perform a one--step checksum computing; return a bytevector holding the
result.  @manpage{SHA1, SHA1}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha224
@subsection Computing SHA224 hash checksums


@menu
* plain hash sha224 struct::       Hash checksum data structures.
* plain hash sha224 api::          Context updating functions.
* plain hash sha224 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash sha224 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} sha224-ctx
@cindex @var{SHA224} argument
@cindex Argument @var{SHA224}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{SHA224_CTX}; it references an SHA224 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{SHA224}.

There are two categories of @code{sha224-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{sha224-ctx} instances returned by @func{sha224-init} do own the context.
When instances of this category are garbage collected or when
@func{md5-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun sha224-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{sha224-ctx}; otherwise
return @false{}.
@end defun


@defun sha224-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{sha224-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun sha224-ctx-custom-destructor @var{SHA224}
@defunx set-sha224-ctx-custom-destructor! @var{SHA224} @var{func}
Retrieve or set a destructor function associated to the @var{SHA224}.

Whenever the @var{SHA224} is closed, either explicitly with
@func{sha224-final} or implicitly by the garbage collector, @var{func} is
applied to @var{SHA224} before the internal state of @var{SHA224} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{SHA224}; if we do:

@example
(define context ...)
(set-sha224-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((sha224-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{SHA224}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} sha224-ctx @var{obj}
@deffnx {Validation Clause} false-or-sha224-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{sha224-ctx?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} sha224-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-sha224-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{sha224-ctx?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain hash sha224 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha224-init
Allocate and initialise a new instance of @code{sha224-ctx}; if successful
return the struct, else return @false{}.  @manpage{SHA224_Init, SHA224_Init}
@end defun


@defun sha224-final @var{SHA224}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{SHA224_Final,
SHA224_Final}.  It is fine to apply this function multiple times to the
same @var{SHA224} argument.
@end defun


@defun sha224-update @var{SHA224} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{SHA224_Update, SHA224_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha224 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha224 @var{input}
@defunx sha224 @var{input} @var{input.len}
Perform a one--step checksum computing; return a bytevector holding the
result.  @manpage{SHA224, SHA224}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha256
@subsection Computing SHA256 hash checksums


@menu
* plain hash sha256 struct::       Hash checksum data structures.
* plain hash sha256 api::          Context updating functions.
* plain hash sha256 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash sha256 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} sha256-ctx
@cindex @var{SHA256} argument
@cindex Argument @var{SHA256}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{SHA256_CTX}; it references an SHA256 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{SHA256}.

There are two categories of @code{sha256-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{sha256-ctx} instances returned by @func{sha256-init} do own the context.
When instances of this category are garbage collected or when
@func{md5-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun sha256-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{sha256-ctx}; otherwise
return @false{}.
@end defun


@defun sha256-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{sha256-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun sha256-ctx-custom-destructor @var{SHA256}
@defunx set-sha256-ctx-custom-destructor! @var{SHA256} @var{func}
Retrieve or set a destructor function associated to the @var{SHA256}.

Whenever the @var{SHA256} is closed, either explicitly with
@func{sha256-final} or implicitly by the garbage collector, @var{func} is
applied to @var{SHA256} before the internal state of @var{SHA256} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{SHA256}; if we do:

@example
(define context ...)
(set-sha256-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((sha256-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{SHA256}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} sha256-ctx @var{obj}
@deffnx {Validation Clause} false-or-sha256-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{sha256-ctx?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} sha256-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-sha256-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{sha256-ctx?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain hash sha256 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha256-init
Allocate and initialise a new instance of @code{sha256-ctx}; if successful
return the struct, else return @false{}.  @manpage{SHA256_Init, SHA256_Init}
@end defun


@defun sha256-final @var{SHA256}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{SHA256_Final,
SHA256_Final}.  It is fine to apply this function multiple times to the
same @var{SHA256} argument.
@end defun


@defun sha256-update @var{SHA256} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{SHA256_Update, SHA256_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha256 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha256 @var{input}
@defunx sha256 @var{input} @var{input.len}
Perform a one--step checksum computing; return a bytevector holding the
result.  @manpage{SHA256, SHA256}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha384
@subsection Computing SHA384 hash checksums


@menu
* plain hash sha384 struct::       Hash checksum data structures.
* plain hash sha384 api::          Context updating functions.
* plain hash sha384 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash sha384 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} sha384-ctx
@cindex @var{SHA384} argument
@cindex Argument @var{SHA384}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{SHA384_CTX}; it references an SHA384 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{SHA384}.

There are two categories of @code{sha384-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{sha384-ctx} instances returned by @func{sha384-init} do own the context.
When instances of this category are garbage collected or when
@func{md5-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun sha384-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{sha384-ctx}; otherwise
return @false{}.
@end defun


@defun sha384-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{sha384-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun sha384-ctx-custom-destructor @var{SHA384}
@defunx set-sha384-ctx-custom-destructor! @var{SHA384} @var{func}
Retrieve or set a destructor function associated to the @var{SHA384}.

Whenever the @var{SHA384} is closed, either explicitly with
@func{sha384-final} or implicitly by the garbage collector, @var{func} is
applied to @var{SHA384} before the internal state of @var{SHA384} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{SHA384}; if we do:

@example
(define context ...)
(set-sha384-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((sha384-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{SHA384}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} sha384-ctx @var{obj}
@deffnx {Validation Clause} false-or-sha384-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{sha384-ctx?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} sha384-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-sha384-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{sha384-ctx?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain hash sha384 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha384-init
Allocate and initialise a new instance of @code{sha384-ctx}; if successful
return the struct, else return @false{}.  @manpage{SHA384_Init, SHA384_Init}
@end defun


@defun sha384-final @var{SHA384}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{SHA384_Final,
SHA384_Final}.  It is fine to apply this function multiple times to the
same @var{SHA384} argument.
@end defun


@defun sha384-update @var{SHA384} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{SHA384_Update, SHA384_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha384 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha384 @var{input}
@defunx sha384 @var{input} @var{input.len}
Perform a one--step checksum computing; return a bytevector holding the
result.  @manpage{SHA384, SHA384}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha512
@subsection Computing SHA512 hash checksums


@menu
* plain hash sha512 struct::       Hash checksum data structures.
* plain hash sha512 api::          Context updating functions.
* plain hash sha512 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash sha512 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} sha512-ctx
@cindex @var{SHA512} argument
@cindex Argument @var{SHA512}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{SHA512_CTX}; it references an SHA512 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{SHA512}.

There are two categories of @code{sha512-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{sha512-ctx} instances returned by @func{sha512-init} do own the context.
When instances of this category are garbage collected or when
@func{md5-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun sha512-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{sha512-ctx}; otherwise
return @false{}.
@end defun


@defun sha512-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{sha512-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun sha512-ctx-custom-destructor @var{SHA512}
@defunx set-sha512-ctx-custom-destructor! @var{SHA512} @var{func}
Retrieve or set a destructor function associated to the @var{SHA512}.

Whenever the @var{SHA512} is closed, either explicitly with
@func{sha512-final} or implicitly by the garbage collector, @var{func} is
applied to @var{SHA512} before the internal state of @var{SHA512} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{SHA512}; if we do:

@example
(define context ...)
(set-sha512-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((sha512-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{SHA512}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} sha512-ctx @var{obj}
@deffnx {Validation Clause} false-or-sha512-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{sha512-ctx?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} sha512-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-sha512-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{sha512-ctx?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain hash sha512 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha512-init
Allocate and initialise a new instance of @code{sha512-ctx}; if successful
return the struct, else return @false{}.  @manpage{SHA512_Init, SHA512_Init}
@end defun


@defun sha512-final @var{SHA512}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{SHA512_Final,
SHA512_Final}.  It is fine to apply this function multiple times to the
same @var{SHA512} argument.
@end defun


@defun sha512-update @var{SHA512} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{SHA512_Update, SHA512_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha512 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha512 @var{input}
@defunx sha512 @var{input} @var{input.len}
Perform a one--step checksum computing; return a bytevector holding the
result.  @manpage{SHA512, SHA512}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash ripemd160
@subsection Computing RIPEMD160 hash checksums


@menu
* plain hash ripemd160 struct::       Hash checksum data structures.
* plain hash ripemd160 api::          Context updating functions.
* plain hash ripemd160 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash ripemd160 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} ripemd160-ctx
@cindex @var{RIPEMD160} argument
@cindex Argument @var{RIPEMD160}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{RIPEMD160_CTX}; it references an RIPEMD160 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{RIPEMD160}.

There are two categories of @code{ripemd160-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{ripemd160-ctx} instances returned by @func{ripemd160-init} do own the context.
When instances of this category are garbage collected or when
@func{md5-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun ripemd160-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{ripemd160-ctx}; otherwise
return @false{}.
@end defun


@defun ripemd160-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{ripemd160-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun ripemd160-ctx-custom-destructor @var{RIPEMD160}
@defunx set-ripemd160-ctx-custom-destructor! @var{RIPEMD160} @var{func}
Retrieve or set a destructor function associated to the @var{RIPEMD160}.

Whenever the @var{RIPEMD160} is closed, either explicitly with
@func{ripemd160-final} or implicitly by the garbage collector, @var{func} is
applied to @var{RIPEMD160} before the internal state of @var{RIPEMD160} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{RIPEMD160}; if we do:

@example
(define context ...)
(set-ripemd160-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((ripemd160-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{RIPEMD160}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} ripemd160-ctx @var{obj}
@deffnx {Validation Clause} false-or-ripemd160-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{ripemd160-ctx?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} ripemd160-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-ripemd160-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{ripemd160-ctx?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain hash ripemd160 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun ripemd160-init
Allocate and initialise a new instance of @code{ripemd160-ctx}; if successful
return the struct, else return @false{}.  @manpage{RIPEMD160_Init, RIPEMD160_Init}
@end defun


@defun ripemd160-final @var{RIPEMD160}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{RIPEMD160_Final,
RIPEMD160_Final}.  It is fine to apply this function multiple times to the
same @var{RIPEMD160} argument.
@end defun


@defun ripemd160-update @var{RIPEMD160} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{RIPEMD160_Update, RIPEMD160_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash ripemd160 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun ripemd160 @var{input}
@defunx ripemd160 @var{input} @var{input.len}
Perform a one--step checksum computing; return a bytevector holding the
result.  @manpage{RIPEMD160, RIPEMD160}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash whirlpool
@subsection Computing WHIRLPOOL hash checksums


@menu
* plain hash whirlpool struct::       Hash checksum data structures.
* plain hash whirlpool api::          Context updating functions.
* plain hash whirlpool direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash whirlpool struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} whirlpool-ctx
@cindex @var{WHIRLPOOL} argument
@cindex Argument @var{WHIRLPOOL}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{WHIRLPOOL_CTX}; it references an WHIRLPOOL hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{WHIRLPOOL}.

There are two categories of @code{whirlpool-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{whirlpool-ctx} instances returned by @func{whirlpool-init} do own the context.
When instances of this category are garbage collected or when
@func{whirlpool-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun whirlpool-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{whirlpool-ctx}; otherwise
return @false{}.
@end defun


@defun whirlpool-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{whirlpool-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun whirlpool-ctx-custom-destructor @var{WHIRLPOOL}
@defunx set-whirlpool-ctx-custom-destructor! @var{WHIRLPOOL} @var{func}
Retrieve or set a destructor function associated to the @var{WHIRLPOOL}.

Whenever the @var{WHIRLPOOL} is closed, either explicitly with
@func{whirlpool-final} or implicitly by the garbage collector, @var{func} is
applied to @var{WHIRLPOOL} before the internal state of @var{WHIRLPOOL} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{WHIRLPOOL}; if we do:

@example
(define context ...)
(set-whirlpool-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((whirlpool-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{WHIRLPOOL}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} whirlpool-ctx @var{obj}
@deffnx {Validation Clause} false-or-whirlpool-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{whirlpool-ctx?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} whirlpool-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-whirlpool-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{whirlpool-ctx?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain hash whirlpool api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun whirlpool-init
Allocate and initialise a new instance of @code{whirlpool-ctx}; if successful
return the struct, else return @false{}.  @manpage{WHIRLPOOL_Init, WHIRLPOOL_Init}
@end defun


@defun whirlpool-final @var{WHIRLPOOL}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{WHIRLPOOL_Final,
WHIRLPOOL_Final}.  It is fine to apply this function multiple times to the
same @var{WHIRLPOOL} argument.
@end defun


@defun whirlpool-update @var{WHIRLPOOL} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{WHIRLPOOL_Update, WHIRLPOOL_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash whirlpool direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun whirlpool @var{input}
@defunx whirlpool @var{input} @var{input.len}
Perform a one--step checksum computing; return a bytevector holding the
result.  @manpage{WHIRLPOOL, WHIRLPOOL}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hmac
@section Computing message authentication codes


@menu
* plain hmac struct::           HMAC data structures.
* plain hmac api::              Context updating functions.
* plain hmac direct::           Directly computing HMACs.
@end menu

@c page
@node plain hmac struct
@subsection HMAC data structures


The following bindings are exported by the library @library{vicare
crypto openssl hmac}.


@deftp {Struct Type} hmac-ctx
@cindex @var{HMAC} argument
@cindex Argument @var{HMAC}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{HMAC_CTX}; it references an HMAC hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{HMAC}.

There are two categories of @code{hmac-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{hmac-ctx} instances returned by @func{hmac-init} do own the
context.  When instances of this category are garbage collected or when
@func{hmac-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun hmac-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{hmac-ctx}; otherwise
return @false{}.
@end defun


@defun hmac-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{hmac-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun hmac-ctx-custom-destructor @var{HMAC}
@defunx set-hmac-ctx-custom-destructor! @var{HMAC} @var{func}
Retrieve or set a destructor function associated to the @var{HMAC}.

Whenever the @var{HMAC} is closed, either explicitly with
@func{hmac-final} or implicitly by the garbage collector, @var{func} is
applied to @var{HMAC} before the internal state of @var{HMAC} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{HMAC}; if we do:

@example
(define context ...)
(set-hmac-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((hmac-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{HMAC}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} hmac-ctx @var{obj}
@deffnx {Validation Clause} false-or-hmac-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{hmac-ctx?}; the
second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} hmac-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-hmac-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{hmac-ctx?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain hmac api
@subsection Context updating functions


Usage example:

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl hmac) ssl.))

(let ((ctx (ssl.hmac-init "key" 'md5)))
  (ssl.hmac-update ctx "ciao")
  (ssl.hmac-final ctx))
@result{} #vu8(104 95 146 126 133 66
   104 215 19 225 230 101 126 75 39 188)
@end example

The following bindings are exported by the library @library{vicare
crypto openssl}.


@defun hmac-init @var{key} @var{md}
@defunx hmac-init @var{key} @var{key.len} @var{md}
Allocate and initialise a new instance of @code{hmac-ctx}; if successful
return the struct, else return @false{}.  Notice that this Scheme
function performs the work of both @cfunc{HMAC_CTX_init} and
@cfunc{HMAC_Init}.  @manpage{HMAC_Init, HMAC_Init}.

@var{key} must be a generalised C string, @vicareref{cbuffers strings,
Introduction to generalised C strings}.  When @var{key} is a string: it
is converted to a bytevector with @func{string->utf8}.

The optional @var{key.len} must be @false{} or an exact integer in the
range of the C language type @code{size_t}.  When @var{key} is a pointer
object: @var{key.len} must represent the number of bytes available in
the referenced memory block; otherwise @var{key.len} is ignored.

@var{md} must be either an instance of @code{evp-md} or a symbol among:

@example
md4             md5             mdc2
sha1            sha224          sha256
sha384          sha512          ripemd160
whirlpool       dss             dss1
@end example
@end defun


@defun hmac-final @var{HMAC}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  Notice that this Scheme
function performs the work of both @cfunc{HMAC_CTX_cleaup} and
@cfunc{HMAC_Final}.  @manpage{HMAC_Final, HMAC_Final}.  It is fine to
apply this function multiple times to the same @var{HMAC} argument.
@end defun


@defun hmac-update @var{HMAC} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{HMAC_Update, HMAC_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun


@defun hmac-ctx-copy @var{DST-HMAC} @var{SRC-HMAC}
Duplicate an HMAC context from @var{SRC-HMAC} to @var{DST-HMAC}; if
successful return true, else return @false{}.  @manpage{HMAC_CTX_copy,
HMAC_CTX_copy}.
@end defun


@defun hmac-ctx-set-flags @var{HMAC} @var{flags}
Set flags in an HMAC context; return unspecified values.
@manpage{HMAC_CTX_copy, HMAC_CTX_copy}.
@end defun

@c page
@node plain hmac direct
@subsection Directly computing HMACs


The following bindings are exported by the library @library{vicare
crypto openssl hmac}.


@defun hmac @var{md} @var{key} @var{key.len} @var{input} @var{input.len}
Perform a one--step HMAC computing; return a bytevector holding the
result, or @false{} if an error occurs.  @manpage{HMAC, HMAC}.

@var{md} must be an instance of @code{evp-md} or a symbol among:

@example
md4             md5             mdc2
sha1            sha224          sha256
sha384          sha512          ripemd160
whirlpool       dss             dss1
@end example

@var{key} and @var{key.len} must represent a generalised C string,
@cstringsref{}.  When @var{key} is a string: it is converted to a
bytevector with @func{string->utf8}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain crypto
@section Low--level cryptographic algorithms.


@menu
* plain crypto aes::            The AES algorithm.
@end menu

@c page
@node plain crypto aes
@subsection The AES algorithm


The cryptographic algorithm AES operates on blocks of size @math{16}.

@menu
* plain crypto aes struct::     Context data structure.
* plain crypto aes key::        Selecting the key.
* plain crypto aes crypt::      Encryption and decryption.
* plain crypto aes misc::       Miscellaneous functions and syntaxes.
@end menu

@c page
@node plain crypto aes struct
@subsubsection Context data structure


The following bindings are exported by the library @library{vicare
crypto openssl aes}.


@deftp {Struct Type} aes-key
@cindex @var{AES} argument
@cindex Argument @var{AES}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{AES_KEY}; it references an AES encryption or
decryption key.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{AES}.

There are two categories of @code{aes-key} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{aes-key} instances returned by @func{aes-set-encrypt-key} and
@func{aes-set-decrypt-key} do own the context.  When instances of this
category are garbage collected: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun aes-key? @var{obj}
Return @true{} if @var{obj} is an instance of @code{aes-key}; otherwise
return @false{}.
@end defun


@defun aes-key?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{aes-key} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun aes-key-custom-destructor @var{AES}
@defunx set-aes-key-custom-destructor! @var{AES} @var{func}
Retrieve or set a destructor function associated to the @var{AES}.

Whenever the @var{AES} is closed: @var{func} is applied to @var{AES}
before the internal state of @var{AES} is finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{AES}; if we do:

@example
(define context ...)
(set-aes-key-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((aes-key-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{AES}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} aes-key @var{obj}
@deffnx {Validation Clause} false-or-aes-key @var{obj}
Succeed if @var{obj} satisfies the predicate @func{aes-key?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} aes-key/alive @var{obj}
@deffnx {Validation Clause} false-or-aes-key/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{aes-key?/alive}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain crypto aes key
@subsubsection Selecting the key


The following bindings are exported by the library @library{vicare
crypto openssl aes}.


@defun aes-set-encrypt-key @var{key}
@defunx aes-set-encrypt-key @var{key} @var{key.len}
Build an instance of @code{aes-ctx} initialised with the encryption
@var{key} and configured with @var{bits}; if successful return the
struct, else return @false{}.

@var{key} and @var{key.len} must represent a generalised C string,
@cstringsref{}.  When @var{key} is a string: it is converted to a
bytevector with @func{string->ascii}.  The key length, measured in
bytes, must be: @math{16}, @math{24} or @math{32}; corresponding to a
length measured in bits of: @math{128}, @math{192}, @math{256}.
@end defun


@defun aes-set-decrypt-key @var{key}
@defunx aes-set-decrypt-key @var{key} @var{key.len}
Build an instance of @code{aes-ctx} initialised with the decryption
@var{key} and configured with @var{bits}; if successful return the
struct, else return @false{}.

@var{key} and @var{key.len} must represent a generalised C string,
@cstringsref{}.  When @var{key} is a string: it is converted to a
bytevector with @func{string->ascii}.  The key length, measured in
bytes, must be: @math{16}, @math{24} or @math{32}; corresponding to a
length measured in bits of: @math{128}, @math{192}, @math{256}.
@end defun

@c page
@node plain crypto aes crypt
@subsubsection Encryption and decryption


The following bindings are exported by the library @library{vicare
crypto openssl aes}.


@defun aes-encrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES}
@defunx aes-decrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES}
Encrypt or decrypt the single data block @var{in} and store the result
in @var{ou}; return unspecified values.

@var{in}, @var{in.len} and @var{ou}, @var{ou.len} must represent
generalised C buffers, @cbuffersref{}.  Their length must be equal to
@code{AES_BLOCK_SIZE} (@math{16}).  @var{in} and @var{ou} can overlap
and also be the same argument.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl aes) ssl.)
  (prefix (vicare crypto openssl constants) ssl.)

(define key.en (ssl.aes-set-encrypt-key "0123456789012345"))
(define key.de (ssl.aes-set-decrypt-key "0123456789012345"))

(define data.in (make-bytevector ssl.AES_BLOCK_SIZE 123))
(define data.en (make-bytevector ssl.AES_BLOCK_SIZE 0))
(define data.de (make-bytevector ssl.AES_BLOCK_SIZE 0))

(ssl.aes-encrypt data.in #f data.en #f key.en)
(ssl.aes-decrypt data.en #f data.de #f key.de)

data.in @result{} #vu8(123 123 123 123 123 123
   123 123 123 123 123 123 123 123 123 123)

data.en @result{} #vu8(204 84 141 21 154 178 104
   243 186 57 101 209 29 113 127 2)

data.de @result{} #vu8(123 123 123 123 123 123
   123 123 123 123 123 123 123 123 123 123)
@end example
@end defun


@defun aes-ecb-encrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES}
@defunx aes-ecb-decrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES}
Encrypt or decrypt the single data block @var{in}, using the ECB scheme,
and store the result in @var{ou}; return unspecified values.

@var{in}, @var{in.len} and @var{ou}, @var{ou.len} must represent
generalised C buffers, @cbuffersref{}.  Their length must be equal to
@code{AES_BLOCK_SIZE} (@math{16}).  @var{in} and @var{ou} can overlap
and also be the same argument.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl aes) ssl.)
  (prefix (vicare crypto openssl constants) ssl.)

(define key.en (ssl.aes-set-encrypt-key "0123456789012345"))
(define key.de (ssl.aes-set-decrypt-key "0123456789012345"))

(define data.in (make-bytevector ssl.AES_BLOCK_SIZE 123))
(define data.en (make-bytevector ssl.AES_BLOCK_SIZE 0))
(define data.de (make-bytevector ssl.AES_BLOCK_SIZE 0))

(ssl.aes-ecb-encrypt data.in #f data.en #f key.en)
(ssl.aes-ecb-decrypt data.en #f data.de #f key.de)
@end example
@end defun


@defun aes-cbc-encrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES} @var{iv} @var{iv.len}
@defunx aes-cbc-decrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES} @var{iv} @var{iv.len}
Encrypt or decrypt multiple data blocks @var{in}, using the CBC scheme,
and store the result in @var{ou}; return unspecified values.

@var{in}, @var{in.len} and @var{ou}, @var{ou.len} must represent
generalised C buffers, @cbuffersref{}.  Their length must be an exact
multiple of @code{AES_BLOCK_SIZE} (@math{16}).  @var{in} and @var{ou}
can overlap and also be the same argument.

@var{iv} and @var{iv.len} must represent a generalised C buffer holding
the initialisation vector, @cbuffersref{}.  Its length must be equal to
@code{AES_BLOCK_SIZE}.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl aes) ssl.)
  (prefix (vicare crypto openssl constants) ssl.)

(define key.en (ssl.aes-set-encrypt-key "0123456789012345"))
(define key.de (ssl.aes-set-decrypt-key "0123456789012345"))

(define iv (make-bytevector ssl.AES_BLOCK_SIZE 99))

(define data.len (* 5 ssl.AES_BLOCK_SIZE))
(define data.in (make-bytevector data.len 123))
(define data.en (make-bytevector data.len 0))
(define data.de (make-bytevector data.len 0))

(ssl.aes-cbc-encrypt data.in #f data.en #f key.en iv #f)
(ssl.aes-cbc-decrypt data.en #f data.de #f key.de iv #f)
@end example
@end defun


@c page
@node plain crypto aes misc
@subsubsection Miscellaneous functions and syntaxes


The following bindings are exported by the library @library{vicare
crypto openssl aes}.


@defun aes-options
If successful return a string representing some kind of options,
otherwise raise an @condition{error} condition.
@end defun


@defun aes-block-len? @var{obj}
Return @true{} if @var{obj} is a fixnum equal to the AES block size;
otherwise return @false{}.
@end defun


@defun aes-data-len? @var{obj}
Return @true{} if @var{obj} is a fixnum equal to an exact multiple of
the AES block size; otherwise return @false{}.
@end defun


@defun aes-key-len? @var{obj}
Return @true{} if @var{obj} is a fixnum representing a valid AES key
length; valid values are: @math{16}, @math{24}, @math{32}.  Otherwise
return @false{}.
@end defun


@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} aes-block-len @var{buf} @var{buf.len}
@var{buf} and @var{buf.len} must represent a generalised C buffer,
@cbuffersref{}.  Succeed if the length of the buffer equals the AES
block size.
@end deffn


@deffn {Validation Clause} aes-data-len @var{buf} @var{buf.len}
@var{buf} and @var{buf.len} must represent a generalised C buffer,
@cbuffersref{}.  Succeed if the length of the buffer is an exact
multiple of the AES block size.
@end deffn


@deffn {Validation Clause} aes-key-len @var{obj}
Succeed if @var{obj} is a finxum representing a valid AES key length;
valid values are: @math{16}, @math{24}, @math{32}.
@end deffn

@c page
@node plain evp
@section High--level cryptographic functions


@menu
* plain evp md algo::           Message digest algorithms.
* plain evp md ctx::            Message digest generation.
* plain evp cipher algo::       Cipher algorithms.
* plain evp cipher ctx::        Encryption and decription contexts.
* plain evp symbols::           Constants to symbols.
@end menu

@c page
@node plain evp md algo
@subsection Message digest algorithms


@menu
* plain evp md algo struct::    Algorithm data structure.
* plain evp md algo makers::    Algorithm reference makers.
* plain evp md algo inspect::   Algorithm inspection.
* plain evp md algo step::      Single-step message digest.
@end menu

@c page
@node plain evp md algo struct
@subsubsection Algorithm data structure


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@deftp {Struct Type} evp-md
@cindex @var{EVP-MD} argument
@cindex Argument @var{EVP-MD}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{EVP_MD}; it references a message digest algorithm.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{EVP-MD}.

@code{evp-md} instances are just references to algorithm
implementations, they do not have associted dynamic data; their
finalisation can be left to the garbage collector.
@end deftp


@defun evp-md? @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-md}; otherwise
return @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} evp-md @var{obj}
@deffnx {Validation Clause} false-or-evp-md @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-md?}; the second
clause also accepts @false{}.
@end deffn

@c page
@node plain evp md algo makers
@subsubsection Algorithm reference makers


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-md-null
Return a struct of type @code{evp-md} representing a null message digest
algorithm.  The generated message digest hash zero length.
@manpage{EVP_DigestInit, EVP_md_null}.
@end defun


@defun evp-md2
Return a struct of type @code{evp-md} representing the MD2 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_md2}.
@end defun


@defun evp-md4
Return a struct of type @code{evp-md} representing the MD4 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_md4}.
@end defun


@defun evp-md5
Return a struct of type @code{evp-md} representing the MD5 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_md5}.
@end defun


@defun evp-sha
Return a struct of type @code{evp-md} representing the SHA message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha}.
@end defun


@defun evp-sha1
Return a struct of type @code{evp-md} representing the SHA1 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha1}.
@end defun


@defun evp-dss
Return a struct of type @code{evp-md} representing the DSS message
digest algorithm.  @manpage{EVP_DigestInit, EVP_dss}.
@end defun


@defun evp-dss1
Return a struct of type @code{evp-md} representing the DSS1 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_dss1}.
@end defun


@defun evp-ecdsa
Return a struct of type @code{evp-md} representing the ECDSA message
digest algorithm.  @manpage{EVP_DigestInit, EVP_ecdsa}.
@end defun


@defun evp-sha224
Return a struct of type @code{evp-md} representing the SHA224 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha224}.
@end defun


@defun evp-sha256
Return a struct of type @code{evp-md} representing the SHA256 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha256}.
@end defun


@defun evp-sha384
Return a struct of type @code{evp-md} representing the SHA384 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha384}.
@end defun


@defun evp-sha512
Return a struct of type @code{evp-md} representing the SHA512 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha512}.
@end defun


@defun evp-mdc2
Return a struct of type @code{evp-md} representing the MDC2 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_mdc2}.
@end defun


@defun evp-ripemd160
Return a struct of type @code{evp-md} representing the RIPEMD160 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_ripemd160}.
@end defun


@defun evp-whirlpool
Return a struct of type @code{evp-md} representing the WHIRLPOOL message
digest algorithm.  @manpage{EVP_DigestInit, EVP_whirlpool}.
@end defun

@c ------------------------------------------------------------

@defun evp-get-digestbyname @var{name}
If successful return a struct of type @code{evp-md} representing the
specified message digest algorithm; otherwise return @false{}.
@manpage{EVP_DigestInit, EVP_get_digestbyname}.

@var{str} must represent a generalised C string holding an @asciiz{}
string, @cstringsref{}.  When @var{str} is a string: it is converted to
a bytevector with @func{string->ascii}.

Examples of valid names: @samp{MD5}, @samp{SHA1}, @samp{SHA224},
@samp{SHA256}, @samp{SHA384}, @samp{SHA512}.
@end defun

@c page
@node plain evp md algo inspect
@subsubsection Algorithm inspection


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-md-name @var{EVP-MD}
Return a string representing the name of the message digest algorithm.
@manpage{EVP_DigestInit, EVP_MD_name}.
@end defun


@defun evp-md-size @var{EVP-MD}
Return an exact integer representing the message digest size produced by
the algorithm specfied by the @code{EVP_MD} structure referenced by the
pointer object @var{EVP-MD-PTR}.  @manpage{EVP_DigestInit, EVP_MD_size}.
@end defun


@defun evp-md-block-size @var{EVP-MD}
Return an exact integer representing the block size produced by the
algorithm specfied by the @code{EVP_MD} structure referenced by the
pointer object @var{EVP-MD-PTR}.  @manpage{EVP_DigestInit,
EVP_MD_block_size}.
@end defun


@defun evp-md-type @var{EVP-MD}
@defunx evp-md-nid @var{EVP-MD}
Return an exact integer representing the NID of the OBJECT IDENTIFIER
representing the given message digest algorithm.
@manpage{EVP_DigestInit, EVP_MD_type}.
@end defun


@defun evp-md-flags @var{EVP-MD}
Return an exact integer representing the flags associated to the given
message digest algorithm.  @manpage{EVP_DigestInit, EVP_MD_flags}.
@end defun


@defun evp-md-pkey-type @var{EVP-MD}
Return an exact integer representing the pkey type (whatever it is) of
the given message digest algorithm.  @manpage{EVP_DigestInit,
EVP_MD_pkey_type}.
@end defun

@c page
@node plain evp md algo step
@subsubsection Single-step message digest


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-digest @var{str} @var{algo}
@defunx evp-digest @var{str} @var{str.len} @var{algo}
Compute a message digest in a single step; if successful return a
bytevector representing the digest, otherwise return @false{}.
@manpage{EVP_DigestInit, EVP_Digest}.

@var{str} and @var{str.len} must represent a generalised C string,
@cstringsref{}.  When @var{str} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain evp md ctx
@subsection Message digest generation


@menu
* plain evp md ctx examples::   Some message digest usage examples.
* plain evp md ctx struct::     Context data structures.
* plain evp md ctx create::     Context creation and destruction.
* plain evp md ctx init::       Context initialisation and finalisation.
* plain evp md ctx update::     Processing input data.
* plain evp md ctx inspect::    Context inspection.
* plain evp md ctx flags::      Context flags.
@end menu

@c page
@node plain evp md ctx examples
@subsubsection Some message digest usage examples


Here is an example of MD5 checksum computation, notice that the
destruction of the context data structure is left to the garbage
collector:

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl evp message-digests) ssl.))

(ssl.openssl-add-all-algorithms)

(define ctx
  (ssl.evp-md-ctx-create))

(ssl.evp-digest-init ctx 'md5)
(ssl.evp-digest-update ctx "ciao")
(ssl.evp-digest-final ctx)
@result{} #vu8(110 107 196 228 157 212 119
   235 201 142 244 4 108 6 123 95)
@end example

@c page
@node plain evp md ctx struct
@subsubsection Hash checksums data structures


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@deftp {Struct Type} evp-md-ctx
@cindex @var{EVP-MD-CTX} argument
@cindex Argument @var{EVP-MD-CTX}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{EVP_MD_CTX}; it references a message digest context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{EVP-MD-CTX}.

There are two categories of @code{evp-md-ctx} instances: those who own
the underlying checksum context and those who merely reference it.

@itemize
@item
@code{evp-md-ctx} instances returned by @func{evp-md-ctx-create} do own
the context.  When instances of this category are garbage collected: the
context is closed, all the associated data is finalised; any error is
ignored in this procedure.
@end itemize
@end deftp


@defun evp-md-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-md-ctx};
otherwise return @false{}.
@end defun


@defun evp-md-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-md-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun evp-md-ctx?/running @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-md-ctx} and the
context it represents is open and initialised with
@func{evp-digest-init}; otherwise return @false{}.
@end defun


@defun evp-md-ctx?/alive-not-running @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-md-ctx} and the
context it represents is open but @strong{not} yet initialised with
@func{evp-digest-init}; otherwise return @false{}.
@end defun


@defun evp-md-ctx-custom-destructor @var{EVP-MD-CTX}
@defunx set-evp-md-ctx-custom-destructor! @var{EVP-MD-CTX} @var{func}
Retrieve or set a destructor function associated to the @var{EVP-MD-CTX}.

Whenever the @var{EVP-MD-CTX} is closed: @var{func} is applied to
@var{EVP-MD-CTX} before the internal state of @var{EVP-MD-CTX} is finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{EVP-MD-CTX}; if we do:

@example
(define context ...)
(set-evp-md-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((evp-md-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{EVP-MD-CTX}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} evp-md-ctx @var{obj}
@deffnx {Validation Clause} false-or-evp-md-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-md-ctx?}; the
second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} evp-md-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-evp-md-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-md-ctx?/alive};
the second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} evp-md-ctx/running @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-md-ctx?/running}.
@end deffn


@deffn {Validation Clause} evp-md-ctx/alive-not-running @var{obj}
Succeed if @var{obj} satisfies the predicate
@func{evp-md-ctx?/alive-not-running}.
@end deffn

@c page
@node plain evp md ctx create
@subsubsection Context creation and destruction


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-md-ctx-create
Build a new struct of type @code{evp-md-ctx}; if successful return the
data struct, otherwise return @false{}.  Returned data structures are
not yet initialised with a message digest algorithm.
@manpage{EVP_DigestInit, EVP_MD_CTX_create}.
@end defun


@defun evp-md-ctx-destroy @var{EVP-MD-CTX}
Finalise a struct of type @code{evp-md-ctx}, releasing all the
associated resources; return unspecified values.  It is fine to apply
this function multiple times to the same instance of @var{EVP-MD-CTX}.
@manpage{EVP_DigestInit, EVP_MD_CTX_destroy}.
@end defun

@c page
@node plain evp md ctx init
@subsubsection Context initialisation and finalisation


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-digest-init @var{EVP-MD-CTX} @var{md}
Initialise an already built message digest context to produce a hash
checksum of type @var{md}; if successful return @true{}, else return
@false{}.  @manpage{EVP_DigestInit, EVP_DigestInit_ex}.

@var{md} must be an instance of @code{evp-md} or a symbol among:

@example
md4             md5             mdc2
sha1            sha224          sha256
sha384          sha512          ripemd160
whirlpool       dss             dss1
@end example

It is an error to apply this function to an already initialised
@var{EVP-MD-CTX}.
@end defun


@defun evp-digest-final @var{EVP-MD-CTX}
Finalise the generation of a message digest checksum; if succesful
return a bytevector representing the sum, otherwise return @false{}.
@manpage{EVP_DigestInit, EVP_DigestFinal_ex}.

It is an error to apply this function to a non--initialised
@var{EVP-MD-CTX}.
@end defun


@defun evp-md-ctx-copy @var{DST-EVP-MD} @var{SRC-EVP-MD}
Copy a message digest state from @var{SRC-EVP-MD} to @var{DST-EVP-MD};
if successful return @true{}, otherwise return @false{}.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl evp message-digests) ssl.))

(ssl.openssl-add-all-algorithms)

(define src (ssl.evp-md-ctx-create))
(ssl.evp-digest-init src 'md5)
(ssl.evp-digest-update src "ciao")

(define dst (ssl.evp-md-ctx-create))
(ssl.evp-md-ctx-copy dst src)
(ssl.evp-digest-final dst)
@result{} #vu8(110 107 196 228 157 212 119
   235 201 142 244 4 108 6 123 95)
@end example
@end defun

@c page
@node plain evp md ctx update
@subsubsection Processing input data


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-digest-update @var{EVP-MD-CTX} @var{str}
@defunx evp-digest-update @var{EVP-MD-CTX} @var{str} @var{str.len}
Update a message digest context with input data; if successful return
@true{}, otherwise return @false{}.  @manpage{EVP_DigestInit,
EVP_DigestUpdate}.


@var{str} and @var{str.len} must represent a generalised C string,
@cstringsref{}.  When @var{str} is a string: it is converted to a
bytevector with @func{string->utf8}.

It is an error to apply this function to a non--initialised
@var{EVP-MD-CTX}.
@end defun

@c page
@node plain evp md ctx inspect
@subsubsection Context inspection


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-md-ctx-size @var{EVP-MD-CTX}
Return an exact integer representing the message digest size produced by
@var{EVP-MD-CTX}.  @manpage{EVP_DigestInit, EVP_MD_CTX_size}.
@end defun


@defun evp-md-ctx-block-size @var{EVP-MD-CTX}
Return an exact integer representing the block size produced by
@var{EVP-MD-CTX}.  @manpage{EVP_DigestInit, EVP_MD_CTX_block_size}.
@end defun


@defun evp-md-ctx-type @var{EVP-MD-CTX}
Return an exact integer representing the NID of the OBJECT IDENTIFIER
representing the given message digest context.  @manpage{EVP_DigestInit,
EVP_MD_CTX_type}.
@end defun


@defun evp-md-ctx-md @var{EVP-MD-CTX}
If successful return an instance of @code{evp-md} representing the
algorithm with which the context was initialised; otherwise return
@false{}.  @manpage{EVP_DigestInit, EVP_MD_CTX_md}.
@end defun

@c page
@node plain evp md ctx flags
@subsubsection Context flags


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-md-ctx-set-flags @var{EVP-MD-CTX} @var{flags}
Set the flags for a message digest context.  @manpage{EVP_DigestInit,
EVP_MD_CTX_set_flags}.  Return unspecified values.

@var{flags} must be an exact integer in the range of the C language type
@code{signed int}.
@end defun


@defun evp-md-ctx-clear-flags @var{EVP-MD-CTX} @var{flags}
Clear the flags for a message digest context.  @manpage{EVP_DigestInit,
EVP_MD_CTX_clear_flags}.  Return unspecified values.

@var{flags} must be an exact integer in the range of the C language type
@code{signed int}.
@end defun


@defun evp-md-ctx-test-flags @var{EVP-MD-CTX} @var{flags}
Test the flags for a message digest context.  @manpage{EVP_DigestInit,
EVP_MD_CTX_test_flags}.  Return an exact integer.

@var{flags} must be an exact integer in the range of the C language type
@code{signed int}.
@end defun

@c page
@node plain evp cipher algo
@subsection Cipher algorithms


@menu
* plain evp cipher algo struct::  Cipher algorithms data structures.
* plain evp cipher algo makers::  Algorithm reference makers.
* plain evp cipher algo inspect:: Algorithm inspection.
@end menu

@c page
@node plain evp cipher algo struct
@subsubsection Cipher algorithms data structures


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@deftp {Struct Type} evp-cipher
@cindex @var{EVP-CIPHER} argument
@cindex Argument @var{EVP-CIPHER}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{EVP_CIPHER}; it references an encryption and
decryption algorithm.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{EVP-CIPHER}.

@code{evp-cipher} instances are just references to algorithm
implementations, they do not have associted dynamic data; their
finalisation can be left to the garbage collector.
@end deftp


@defun evp-cipher? @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-cipher};
otherwise return @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} evp-cipher @var{obj}
@deffnx {Validation Clause} false-or-evp-cipher @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-cipher?}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain evp cipher algo makers
@subsubsection Algorithm reference makers


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@macro CipherMakerDefun{WHO}
@defun \WHO\
Build a new struct instance of type @code{evp-cipher}; if successful
return the struct, otherwise return @false{}.
@end defun
@end macro

@CipherMakerDefun{evp-enc-null}
@CipherMakerDefun{evp-des-ecb}
@CipherMakerDefun{evp-des-ede}
@CipherMakerDefun{evp-des-ede3}
@CipherMakerDefun{evp-des-ede-ecb}
@CipherMakerDefun{evp-des-ede3-ecb}
@CipherMakerDefun{evp-des-cfb64}
@CipherMakerDefun{evp-des-cfb}
@CipherMakerDefun{evp-des-ede3-cfb64}
@CipherMakerDefun{evp-des-ede3-cfb}
@CipherMakerDefun{evp-des-ede3-cfb1}
@CipherMakerDefun{evp-des-ede3-cfb8}
@CipherMakerDefun{evp-des-ofb}
@CipherMakerDefun{evp-des-ede-ofb}
@CipherMakerDefun{evp-des-ede3-ofb}
@CipherMakerDefun{evp-des-cbc}
@CipherMakerDefun{evp-des-ede-cbc}
@CipherMakerDefun{evp-des-ede3-cbc}
@CipherMakerDefun{evp-desx-cbc}
@CipherMakerDefun{evp-rc4}
@CipherMakerDefun{evp-rc4-40}
@CipherMakerDefun{evp-rc4-hmac-md5}
@CipherMakerDefun{evp-idea-ecb}
@CipherMakerDefun{evp-idea-cfb64}
@CipherMakerDefun{evp-idea-cfb}
@CipherMakerDefun{evp-idea-ofb}
@CipherMakerDefun{evp-idea-cbc}
@CipherMakerDefun{evp-rc2-ecb}
@CipherMakerDefun{evp-rc2-cbc}
@CipherMakerDefun{evp-rc2-40-cbc}
@CipherMakerDefun{evp-rc2-64-cbc}
@CipherMakerDefun{evp-rc2-cfb64}
@CipherMakerDefun{evp-rc2-cfb}
@CipherMakerDefun{evp-rc2-ofb}

Notice that @code{bf} stands for Blowfish.
@cindex Blowfish cipher.

@CipherMakerDefun{evp-bf-ecb}
@CipherMakerDefun{evp-bf-cbc}
@CipherMakerDefun{evp-bf-cfb64}
@CipherMakerDefun{evp-bf-cfb}
@CipherMakerDefun{evp-bf-ofb}

@CipherMakerDefun{evp-cast5-ecb}
@CipherMakerDefun{evp-cast5-cbc}
@CipherMakerDefun{evp-cast5-cfb64}
@CipherMakerDefun{evp-cast5-cfb}
@CipherMakerDefun{evp-cast5-ofb}
@CipherMakerDefun{evp-rc5-32-12-16-cbc}
@CipherMakerDefun{evp-rc5-32-12-16-ecb}
@CipherMakerDefun{evp-rc5-32-12-16-cfb64}
@CipherMakerDefun{evp-rc5-32-12-16-cfb}
@CipherMakerDefun{evp-rc5-32-12-16-ofb}
@CipherMakerDefun{evp-aes-128-ecb}
@CipherMakerDefun{evp-aes-128-cbc}
@CipherMakerDefun{evp-aes-128-cfb1}
@CipherMakerDefun{evp-aes-128-cfb8}
@CipherMakerDefun{evp-aes-128-cfb128}
@CipherMakerDefun{evp-aes-128-cfb}
@CipherMakerDefun{evp-aes-128-ofb}
@CipherMakerDefun{evp-aes-128-ctr}
@CipherMakerDefun{evp-aes-128-ccm}
@CipherMakerDefun{evp-aes-128-gcm}
@CipherMakerDefun{evp-aes-128-xts}
@CipherMakerDefun{evp-aes-192-ecb}
@CipherMakerDefun{evp-aes-192-cbc}
@CipherMakerDefun{evp-aes-192-cfb1}
@CipherMakerDefun{evp-aes-192-cfb8}
@CipherMakerDefun{evp-aes-192-cfb128}
@CipherMakerDefun{evp-aes-192-cfb}
@CipherMakerDefun{evp-aes-192-ofb}
@CipherMakerDefun{evp-aes-192-ctr}
@CipherMakerDefun{evp-aes-192-ccm}
@CipherMakerDefun{evp-aes-192-gcm}
@CipherMakerDefun{evp-aes-256-ecb}
@CipherMakerDefun{evp-aes-256-cbc}
@CipherMakerDefun{evp-aes-256-cfb1}
@CipherMakerDefun{evp-aes-256-cfb8}
@CipherMakerDefun{evp-aes-256-cfb128}
@CipherMakerDefun{evp-aes-256-cfb}
@CipherMakerDefun{evp-aes-256-ofb}
@CipherMakerDefun{evp-aes-256-ctr}
@CipherMakerDefun{evp-aes-256-ccm}
@CipherMakerDefun{evp-aes-256-gcm}
@CipherMakerDefun{evp-aes-256-xts}
@CipherMakerDefun{evp-aes-128-cbc-hmac-sha1}
@CipherMakerDefun{evp-aes-256-cbc-hmac-sha1}
@CipherMakerDefun{evp-camellia-128-ecb}
@CipherMakerDefun{evp-camellia-128-cbc}
@CipherMakerDefun{evp-camellia-128-cfb1}
@CipherMakerDefun{evp-camellia-128-cfb8}
@CipherMakerDefun{evp-camellia-128-cfb128}
@CipherMakerDefun{evp-camellia-128-cfb}
@CipherMakerDefun{evp-camellia-128-ofb}
@CipherMakerDefun{evp-camellia-192-ecb}
@CipherMakerDefun{evp-camellia-192-cbc}
@CipherMakerDefun{evp-camellia-192-cfb1}
@CipherMakerDefun{evp-camellia-192-cfb8}
@CipherMakerDefun{evp-camellia-192-cfb128}
@CipherMakerDefun{evp-camellia-192-cfb}
@CipherMakerDefun{evp-camellia-192-ofb}
@CipherMakerDefun{evp-camellia-256-ecb}
@CipherMakerDefun{evp-camellia-256-cbc}
@CipherMakerDefun{evp-camellia-256-cfb1}
@CipherMakerDefun{evp-camellia-256-cfb8}
@CipherMakerDefun{evp-camellia-256-cfb128}
@CipherMakerDefun{evp-camellia-256-cfb}
@CipherMakerDefun{evp-camellia-256-ofb}
@CipherMakerDefun{evp-seed-ecb}
@CipherMakerDefun{evp-seed-cbc}
@CipherMakerDefun{evp-seed-cfb128}
@CipherMakerDefun{evp-seed-cfb}
@CipherMakerDefun{evp-seed-ofb}

@c ------------------------------------------------------------

@defun evp-get-cipherbyname @var{name}
Build a new struct instance of type @code{evp-cipher} selecting the
algorithm by its name; if successful return the struct, otherwise return
@false{}.  @manpage{EVP_EncryptInit_ex, EVP_get_cipherbyname}.

@var{name} must represent a generalised C string, @cstringsref{}.  When
@var{str} is a string: it is converted to a bytevector with
@func{string->ascii}.
@end defun


@defun evp-get-cipherbynid @var{nid}
Build a new struct instance of type @code{evp-cipher} selecting the
algorithm by its NID; if successful return the struct, otherwise return
@false{}.  @manpage{EVP_EncryptInit_ex, EVP_get_cipherbynid}.

@var{nid} must be an exact integer, in the range of the C language type
@code{signed int}, representing the NID of a cipher algorithm.  NID
values can be extracted by an @code{evp-cipher} struct using
@func{evp-cipher-nid}.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl evp ciphers) ssl.))

(ssl.openssl-add-all-algorithms)
(ssl.evp-get-cipherbynid 109)
@result{} #[evp-cipher ...]
@end example
@end defun


@ignore
@c Not implemented yet (Marco Maggi; Wed Mar 20, 2013)

@defun evp-get-cipherbyobj @var{ASN-OBJ}
Build a new struct instance of type @code{evp-cipher} selecting the
algorithm by its ASN.1 object; if successful return the struct,
otherwise return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_get_cipherbyobj}.
@end defun
@end ignore

@c page
@node plain evp cipher algo inspect
@subsubsection Algorithm inspection


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-name @var{EVP-CIPHER}
Return a string representing the name of the cipher algorithm.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl evp ciphers) ssl.))

(ssl.openssl-add-all-algorithms)

(ssl.evp-cipher-name (ssl.evp-enc-null))
@result{} "UNDEF"

(ssl.evp-cipher-name (ssl.evp-des-ecb))
@result{} "DES-ECB"

(ssl.evp-cipher-name (ssl.evp-rc4))
@result{} "RC4"

(ssl.evp-cipher-name (ssl.evp-rc2-ecb))
@result{} "RC2-ECB"

(ssl.evp-cipher-name (ssl.evp-cast5-ecb))
@result{} "CAST5-ECB"

(ssl.evp-cipher-name (ssl.evp-camellia-128-ecb))
@result{} "CAMELLIA-128-ECB"
@end example
@end defun


@defun evp-cipher-nid @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the NID of the cipher algorithm.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl evp ciphers) ssl.))

(ssl.openssl-add-all-algorithms)
(ssl.evp-cipher-nid (ssl.evp-cast5-ecb))
@result{} 109
@end example
@end defun


@defun evp-cipher-type @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the type of the cipher algorithm.
@end defun


@defun evp-cipher-block-size @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the block size of the cipher algorithm.
For stream algorithms: the block size is @math{1}.
@end defun


@defun evp-cipher-key-length @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the key length of the cipher algorithm.
@end defun


@defun evp-cipher-iv-length @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the initialisation vector of the cipher
algorithm.  If the algorithm makes no use of initialisation vectors: the
returned value is @math{0}.
@end defun


@defun evp-cipher-mode @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the mode the cipher algorithm.  The
returned value is one of the @code{EVP_CIPH_*_MODE} constants.
@end defun


@defun evp-cipher-flags @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the flags of the cipher algorithm.
@end defun

@c page
@node plain evp cipher ctx
@subsection Encryption and decription contexts


@menu
* plain evp cipher ctx struct::   Cipher context data structures.
* plain evp cipher ctx create::   Context creation and destruction.
* plain evp cipher ctx encrypt::  Encrypting data.
* plain evp cipher ctx decrypt::  Decrypting data.
* plain evp cipher ctx cipher::   Encrypting or decrypting data.
* plain evp cipher ctx inspect::  Context inspection.
* plain evp cipher ctx config::   Context configuration.
* plain evp cipher ctx flags::    Context flags.
* plain evp cipher ctx misc::     Miscellaneous functions.
* plain evp cipher ctx step::     Single-step encryption and decryption.
@end menu

@c page
@node plain evp cipher ctx struct
@subsubsection Cipher context data structures


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@deftp {Struct Type} evp-cipher-ctx
@cindex @var{EVP-CIPHER-CTX} argument
@cindex Argument @var{EVP-CIPHER-CTX}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{EVP_CIPHER_CTX}; it references a message digest
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{EVP-CIPHER-CTX}.

There are two categories of @code{evp-cipher-ctx} instances: those who
own the underlying checksum context and those who merely reference it.

@itemize
@item
@code{evp-cipher-ctx} instances returned by @func{evp-cipher-ctx-new} do
own the context.  When instances of this category are garbage collected
or @func{evp-cipher-ctx-free} is applied to them: the context is closed,
all the associated data is finalised; any error is ignored in this
procedure.
@end itemize
@end deftp


@defun evp-cipher-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-cipher-ctx};
otherwise return @false{}.
@end defun


@defun evp-cipher-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-cipher-ctx} and
the context it represents is open; otherwise return @false{}.
@end defun


@defun evp-cipher-ctx?/running @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-cipher-ctx} and
the context it represents is open and initialised with
@func{evp-encrypt-init} or similar functions; otherwise return @false{}.
@end defun


@defun evp-cipher-ctx?/alive-not-running @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-cipher-ctx} and
the context it represents is open but @strong{not} yet initialised with
@func{evp-encrypt-init} or similar functions; otherwise return @false{}.
@end defun


@defun evp-cipher-ctx-custom-destructor @var{EVP-CIPHER-CTX}
@defunx set-evp-cipher-ctx-custom-destructor! @var{EVP-CIPHER-CTX} @var{func}
Retrieve or set a destructor function associated to the
@var{EVP-CIPHER-CTX}.

Whenever the @var{EVP-CIPHER-CTX} is closed: @var{func} is applied to
@var{EVP-CIPHER-CTX} before the internal state of @var{EVP-CIPHER-CTX}
is finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{EVP-CIPHER-CTX}; if we do:

@example
(define context ...)
(set-evp-cipher-ctx-custom-destructor! context
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((evp-cipher-ctx-custom-destructor context))))
  (do-something-with context state))
@end example

@noindent
we can easily associate values to @var{EVP-CIPHER-CTX}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} evp-cipher-ctx @var{obj}
@deffnx {Validation Clause} false-or-evp-cipher-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-cipher-ctx?}; the
second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} evp-cipher-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-evp-cipher-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate
@func{evp-cipher-ctx?/alive}; the second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} evp-cipher-ctx/running @var{obj}
Succeed if @var{obj} satisfies the predicate
@func{evp-cipher-ctx?/running}.
@end deffn


@deffn {Validation Clause} evp-cipher-ctx/alive-not-running @var{obj}
Succeed if @var{obj} satisfies the predicate
@func{evp-cipher-ctx?/alive-not-running}.
@end deffn

@c page
@node plain evp cipher ctx create
@subsubsection Context creation and destruction


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-ctx-new
Build a new instance of @code{evp-cipher-ctx}; if successful return the
struct instance, else return @false{}.  Returned data structures are not
yet initialised with a cipher algorithm.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_new}.
@end defun


@defun evp-cipher-ctx-free @var{EVP-CIPHER-CTX}
Finalise a cipher context and release all the associated resources;
return unspecified values.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_free}.

It is fine to apply this function multiple times to the same argument:
the first time the context is finalised, subsequent times nothing
happens.
@end defun

@c page
@node plain evp cipher ctx encrypt
@subsubsection Encrypting data


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-encrypt-init @var{EVP-CIPHER-CTX} @var{EVP-CIPHER} @var{key} @var{iv}
Initialise an already built cipher context to encrypt data with the
algorithm selected by @var{EVP-CIPHER}; if successful return @true{},
else return @false{}.  @manpage{EVP_EncryptInit_ex, EVP_EncryptInit_ex}.

@var{key} must be @false{} or represent a generalised C string holding
the encryption key, @cstringsref{}.  When @var{key} is a string: it is
converted to a bytevector with @func{string->utf8}.

@var{iv} must be @false{} or represent a generalised C string holding
the initialisation vector, @cstringsref{}.  When @var{iv} is a string:
it is converted to a bytevector with @func{string->utf8}.
@end defun


@defun evp-encrypt-final @var{EVP-CIPHER-CTX}
Finalise an encryption context; if successful return a bytevector
holding the last output data, else return @false{}.
@manpage{EVP_EncryptInit_ex, EVP_EncryptFinal_ex}.
@end defun


@defun evp-encrypt-update @var{EVP-CIPHER-CTX} @var{ou} @var{ou_len} @var{in} @var{in_len}
Update an encryption context with clear text input data and produce
encrypted output data; if successful return the actual number of bytes
in the output, else return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_EncryptUpdate}.

The arguments @var{in} and @var{in_len} must represent a generalised C
string holding the clear text input data, @cstringsref{}.  When @var{in}
is a string: it is converted to a bytevector with @func{string->utf8}.

The arguments @var{ou} and @var{ou_len} must represent a generalised C
buffer holding empty room for the encrypted output data, @cbuffersref{}.
The length of the output buffer is the maximum number of output bytes
that can be accepted; such length must be:

@enumerate
@item
Less than the greatest fixnum, @code{(greatest-fixnum)}.

@item
Less than the value of @code{INT_MAX} defined by the underlying
platform.

@item
At least the sum between the number of input bytes and the block size of
the selected cipher algorithm.
@end enumerate

The minimum output length can be computed with
@func{evp-minimum-output-length}.
@end defun

@c page
@node plain evp cipher ctx decrypt
@subsubsection Decrypting data


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-decrypt-init @var{EVP-CIPHER-CTX} @var{EVP-CIPHER} @var{key} @var{iv}
Initialise an already built cipher context to decrypt data with the
algorithm selected by @var{EVP-CIPHER}; if successful return @true{},
else return @false{}.  @manpage{EVP_EncryptInit_ex, EVP_DecryptInit_ex}.

@var{key} must be @false{} or represent a generalised C string holding
the decryption key, @cstringsref{}.  When @var{key} is a string: it is
converted to a bytevector with @func{string->utf8}.

@var{iv} must be @false{} or represent a generalised C string holding
the initialisation vector, @cstringsref{}.  When @var{iv} is a string:
it is converted to a bytevector with @func{string->utf8}.
@end defun


@defun evp-decrypt-final @var{EVP-CIPHER-CTX}
Finalise a decryption context; if successful return a bytevector holding
the last output data, else return @false{}.
@manpage{EVP_EncryptInit_ex, EVP_DecryptFinal_ex}.
@end defun


@defun evp-decrypt-update @var{EVP-CIPHER-CTX} @var{ou} @var{ou_len} @var{in} @var{in_len}
Update a decryption context with encrypted text input data and produce
decrypted output data; if successful return the actual number of bytes
in the output, else return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_DecryptUpdate}.

The arguments @var{in} and @var{in_len} must represent a generalised C
buffer holding the encrypted input data, @cbuffersref{}.

The arguments @var{ou} and @var{ou_len} must represent a generalised C
buffer holding empty room for the decrypted output data, @cbuffersref{}.
The length of the output buffer is the maximum number of output bytes
that can be accepted; such length must be:

@enumerate
@item
Less than the greatest fixnum, @code{(greatest-fixnum)}.

@item
Less than the value of @code{INT_MAX} defined by the underlying
platform.

@item
At least the sum between the number of input bytes and the block size of
the selected cipher algorithm.
@end enumerate

The minimum output length can be computed with
@func{evp-minimum-output-length}.
@end defun

@c page
@node plain evp cipher ctx cipher
@subsubsection Encrypting or decrypting data


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-init @var{EVP-CIPHER-CTX} @var{EVP-CIPHER} @var{key} @var{iv} @var{enc}
Initialise an already built cipher context to encrypt or decrypt data
with the algorithm selected by @var{EVP-CIPHER}; if successful return
@true{}, else return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_CipherInit_ex}.

@var{key} must be @false{} or represent a generalised C string holding
the encryption key, @cstringsref{}.  When @var{key} is a string: it is
converted to a bytevector with @func{string->utf8}.

@var{iv} must be @false{} or represent a generalised C string holding
the initialisation vector, @cstringsref{}.  When @var{iv} is a string:
it is converted to a bytevector with @func{string->utf8}.

@var{enc} must be a fixnum: @math{1} for encryption, @math{0} for
decryption, @math{-1} to leave unchanged a previously set value.
@end defun


@defun evp-cipher-final @var{EVP-CIPHER-CTX}
Finalise an encryption or decryption context; if successful return a
bytevector holding the last output data, else return @false{}.
@manpage{EVP_EncryptInit_ex, EVP_CipherFinal_ex}.
@end defun


@defun evp-cipher-update @var{EVP-CIPHER-CTX} @var{ou} @var{ou_len} @var{in} @var{in_len}
Update an encryption or decryption context with input data and produce
output data; if successful return the actual number of bytes in the
output, else return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_CipherUpdate}.

The arguments @var{in} and @var{in_len} must represent a generalised C
string holding the input data, @cstringsref{}.  When @var{in} is a
string: it is converted to a bytevector with @func{string->utf8}.

The arguments @var{ou} and @var{ou_len} must represent a generalised C
buffer holding empty room for the output data, @cbuffersref{}.  The
length of the output buffer is the maximum number of output bytes that
can be accepted; such length must be:

@enumerate
@item
Less than the greatest fixnum, @code{(greatest-fixnum)}.

@item
Less than the value of @code{INT_MAX} defined by the underlying
platform.

@item
At least the sum between the number of input bytes and the block size of
the selected cipher algorithm.
@end enumerate

The minimum output length can be computed with
@func{evp-minimum-output-length}.
@end defun

@c page
@node plain evp cipher ctx inspect
@subsubsection Context inspection


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-ctx-cipher @var{EVP-CIPHER-CTX}
Retrieve the cipher algorithm used by the given context; if successful
return an instance of @code{evp-cipher}, otherwise return @false{}.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_cipher}.
@end defun


@defun evp-cipher-ctx-nid @var{EVP-CIPHER-CTX}
Return an exact integer representing the NID of the cipher algorithm.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_nid}.
@end defun


@defun evp-cipher-ctx-type @var{EVP-CIPHER-CTX}
Return an exact integer representing the type of the cipher algorithm.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_type}.
@end defun


@defun evp-cipher-ctx-block-size @var{EVP-CIPHER-CTX}
Return an exact integer representing the block size of the cipher
algorithm.  @manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_block_size}.
@end defun


@defun evp-cipher-ctx-key-length @var{EVP-CIPHER-CTX}
Return an exact integer representing the key length of the cipher
algorithm.  @manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_key_length}.
@end defun


@defun evp-cipher-ctx-iv-length @var{EVP-CIPHER-CTX}
Return an exact integer representing the initialisation vecttor length
of the cipher algorithm.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_iv_length}.
@end defun


@defun evp-cipher-ctx-mode @var{EVP-CIPHER-CTX}
Return an exact integer representing the mode of the cipher algorithm,
one of the @code{EVP_CIPH_*_MODE} constants.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_mode}.
@end defun

@c page
@node plain evp cipher ctx config
@subsubsection Context configuration


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-ctx-set-key-length @var{EVP-CIPHER-CTX} @var{key.len}
Set the key length to use among the supported values; if successful
return @true{}, otherwise return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_set_key_length}.

@var{key.len} must be an exact integer representing the key length.
@end defun


@defun evp-cipher-ctx-set-padding @var{EVP-CIPHER-CTX} @var{pad?}
Enable or disable padding; if successful return @true{}, otherwise
return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_set_padding}.

If @var{pad?} is true: padding is enabled.  If @var{pad?} is @false{}:
padding is disabled.
@end defun


@defun evp-cipher-ctx-ctrl @var{EVP-CIPHER-CTX} @var{type}
@defunx evp-cipher-ctx-ctrl @var{EVP-CIPHER-CTX} @var{type} @var{arg}
Set or retrieve some context parameters; if successful return @true{},
otherwise return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_set_key_ctrl}.

When the argument @var{arg} @strong{is not} used, @var{type} must be one
of the following:

@table @code
@item EVP_CTRL_GET_RC5_ROUNDS
Return an exact integer representing the number of rounds for the RC5
algorithm.

@item EVP_CTRL_GET_RC2_KEY_BITS
Return an exact integer representing the number of key bits for the RC2
algorithm.
@end table

When the argument @var{arg} @strong{is} used, @var{type} must be one of
the following:

@table @code
@item EVP_CTRL_SET_RC5_ROUNDS
Set to @var{arg} the number of rounds for the RC5 algorithm.

@item EVP_CTRL_SET_RC2_KEY_BITS
Set to @var{arg} the number of key bits for the RC2 algorithm.
@end table
@end defun


@defun evp-cipher-ctx-rand-key @var{EVP-CIPHER-CTX} @var{key}
Set a key for the cipher algorithm; if successful return @true{},
otherwise return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_rand_key}.

@var{key} must be a generalised C string holding an @asciiz{} string,
@cstringsref{}.  When @var{key} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain evp cipher ctx flags
@subsubsection Context flags


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-ctx-flags @var{EVP-CIPHER-CTX}
Return an exact integer representing the context's flags.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_flags}.
@end defun


@defun evp-cipher-ctx-set-flags @var{EVP-CIPHER-CTX} @var{flags}
Set a context's flags; return unspecified values.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_set_flags}.
@end defun


@defun evp-cipher-ctx-clear-flags @var{EVP-CIPHER-CTX} @var{flags}
Clear a context's flags; return unspecified values.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_clear_flags}.
@end defun


@defun evp-cipher-ctx-test-flags @var{EVP-CIPHER-CTX} @var{flags}
Tests a context's flags; return an exact integer.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_test_flags}.
@end defun

@c page
@node plain evp cipher ctx misc
@subsubsection Miscellaneous functions


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-minimum-output-length @var{EVP-CIPHER-CTX} @var{in} @var{in.len}
Compute the minimum output length needed to encrypt or decrypt the given
argument; if successful return an exact integer representing the number
of bytes, else return @false{}.

The arguments @var{in} and @var{in_len} must represent a generalised C
string holding the clear text input data, @cstringsref{}.  When @var{in}
is a string: it is converted to a bytevector with @func{string->utf8}.
@end defun


@defun evp-cipher-ctx-copy @var{EVP-CIPHER-CTX-DST} @var{EVP-CIPHER-CTX-SRC}
Copy the context from @var{EVP-CIPHER-CTX-SRC} to
@var{EVP-CIPHER-CTX-DST}, which must be already initialised; if
successful return @true{}, otherwise return @false{}.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_copy}.
@end defun

@c ------------------------------------------------------------

@defun evp-cipher-ctx-get-app-data @var{EVP-CIPHER-CTX}
Return @false{} or a pointer previously registered as application data
associated to the given context.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_get_app_data}.
@end defun


@defun evp-cipher-ctx-set-app-data @var{EVP-CIPHER-CTX} @var{data}
Register a pointer as application data associated to the given context.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_set_app_data}.

@var{data} must be a pointer object or @false{}; when @var{data} is
@false{}: the @cnull{} pointer is registered.
@end defun

@c ------------------------------------------------------------

@defun evp-cipher-param-to-asn1
@end defun

@defun evp-cipher-asn1-to-param
@end defun

@c page
@node plain evp cipher ctx step
@subsubsection Single--step encryption and decryption


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-crypt
@end defun

@c page
@node plain evp symbols
@subsection Constants to symbols


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-ciph-mode->symbol @var{constant}
Given a constant among @code{EVP_CIPH_*_MODE} return a symbol
representing its public name.
@end defun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest version of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
the home page of the Vicare project is at:

@center @url{http://marcomaggi.github.com/vicare.html}

@noindent
the home page of the Nausicaa project is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
@value{FOREIGN_PACKAGE} can be found here:

@center @value{FOREIGN_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

