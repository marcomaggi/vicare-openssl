\input texinfo.tex
@c %**start of header
@setfilename vicare-openssl.info
@settitle Openssl for Vicare
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@c Insert a documentation chunk describing the common API for data
@c structures wrapping foreign pointers.
@c
@macro StructCommonDoc{PREFIX, STRUCT, FINALISER}
@defun \PREFIX\? @var{obj}
Return @true{} if @var{obj} is an instance of @code{\PREFIX\}; otherwise
return @false{}.
@end defun


@defun \PREFIX\?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{\PREFIX\} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun \PREFIX\-custom-destructor @var{\STRUCT\}
@defunx set-\PREFIX\-custom-destructor! @var{\STRUCT\} @var{func}
Retrieve or set a destructor function associated to the @var{\STRUCT\}.

Whenever the @var{\STRUCT\} is closed, either explicitly with
@func{\FINALISER\} or implicitly by the garbage collector, @var{func} is
applied to @var{\STRUCT\} before the internal state of @var{\STRUCT\} is
finalised.
@end defun
@end macro

@c ------------------------------------------------------------

@c Insert a documentation chunk describing the property lists
@c API for data structures wrapping foreign pointers.
@c
@macro StructPropertyListDoc{PREFIX, STRUCT}
@subsubheading Property lists

@cindex Property lists, @var{\STRUCT\} structures

@defun \PREFIX\-putprop @var{\STRUCT\} @var{key} @var{value}
Add a new property @var{key} with @var{value} to the property list of
@var{\STRUCT\}.  If @var{key} is already set: the old entry is mutated to
reference @var{value}.  @var{key} must be a symbol.
@end defun


@defun \PREFIX\-getprop @var{\STRUCT\} @var{key}
Return the value of the property @var{key} in the property list of
@var{\STRUCT\}; if @var{key} is not set return @false{}.  @var{key} must be a
symbol.
@end defun


@defun \PREFIX\-remprop @var{\STRUCT\} @var{key}
Remove the property @var{key} from the property list of @var{\STRUCT\}.
@var{key} must be a symbol.
@end defun


@defun \PREFIX\-property-list @var{\STRUCT\}
Return a new association list representing the property list of
@var{\STRUCT\}.
@end defun
@end macro

@c ------------------------------------------------------------

@c Insert a documentation chunk describing the arguments validation
@c clauses API for data structures wrapping foreign pointers.
@c
@macro StructArgumentsValidationDoc{PREFIX, STRUCT}
@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} \PREFIX\ @var{obj}
@deffnx {Validation Clause} false-or-\PREFIX\ @var{obj}
Succeed if @var{obj} satisfies the predicate @func{\PREFIX\?}; the second
clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} \PREFIX\/alive @var{obj}
@deffnx {Validation Clause} false-or-\PREFIX\/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{\PREFIX\?/alive}; the
second clause also accepts @false{}.
@end deffn
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Openssl for Vicare

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Vicare/@openssl{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           vicare-openssl

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi.ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2013

@c ------------------------------------------------------------

@set FOREIGN_PACKAGE            @openssl{}
@set FOREIGN_VERSION            1.0.1e
@set FOREIGN_URL                @url{http://www.openssl.org/}
@set FOREIGN_SCHEME_LIB         @library{vicare crypto openssl}
@set GITHUB_URL                 @url{http://github.com/marcomaggi/vicare-openssl}
@set SOURCEFORGE_URL            @url{https://sourceforge.net/projects/vicare-openssl/}
@set DOWNLOAD_URL               @url{https://sourceforge.net/projects/vicare-openssl/files/}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.com/docs/vicare-openssl.html}


@macro opensslref{NODE, TITLE}
@xref{\NODE\,\TITLE\,\TITLE\,openssl}
@end macro

@macro openssl{}
@acronym{OpenSSL}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @version{} of @value{PACKAGE}, a
distribution of C and Scheme libraries for Vicare Scheme, an @rnrs{6}
compliant Scheme implementation; it provides bindings for the
@value{FOREIGN_PACKAGE} C language library.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{SOURCEFORGE_URL}

@noindent
@value{FOREIGN_PACKAGE} is available at:

@center @value{FOREIGN_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* vicare-openssl: (vicare-openssl). @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Openssl version informations.
* plain::                       Plain programming interface.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


Vicare Scheme is an @rnrs{6} compliant Scheme language implementation in
the form of a native compiler for x86 architectures, officially
supporting @gnu{}+Linux systems.  @value{PACKAGE} is a distribution of C
language and Scheme language libraries for Vicare Scheme; it provides
bindings for the @value{FOREIGN_PACKAGE} C language library.

The last time the author bothered to update this paragraph, he had
tested @value{FOREIGN_PACKAGE} version @value{FOREIGN_VERSION}.  This
product includes software developed by the OpenSSL Project for use in
the OpenSSL Toolkit (@url{http://www.openssl.org/}).

The package installs a C language library implementing wrapper C
functions for the C language @value{FOREIGN_PACKAGE} library; on top of
this, the Scheme libraries in the hierarchy @library{vicare crypto
openssl ---} export bindings for some @value{FOREIGN_PACKAGE} public
functions; additionally the library @library{vicare crypto openssl
constants} exports bindings for some constant values defined in the C
language header @file{openssl/ssl.h} and others.

Most of the Scheme function names are directly derived from the C
function names by replacing upper case with lower case and underscore
characters @samp{_} with dash characters @samp{-}; so
@cfunc{SSL_library_init} becomes @func{ssl-library-init}.  In some rare
case a dash is inserted to make the name more readable, for example
@cfunc{EVP_DigestInit} becomes @func{evp-digest-init}.

The following Scheme libraries are installed:

@table @library
@item vicare crypto openssl
@cindex Library @library{vicare crypto openssl}
@cindex @library{vicare crypto openssl}, library
It exports bindings for some @value{FOREIGN_PACKAGE} core public
functions needed for library initialisation.

@item vicare crypto openssl evp message-digests
@cindex Library @library{vicare crypto openssl evp message-digests}
@cindex @library{vicare crypto openssl evp message-digests}, library
It exports bindings for some @value{FOREIGN_PACKAGE} high--level
functions implementing the EVP message digests @api{}.

@item vicare crypto openssl evp ciphers
@cindex Library @library{vicare crypto openssl evp ciphers}
@cindex @library{vicare crypto openssl evp ciphers}, library
It exports bindings for some @value{FOREIGN_PACKAGE} high--level
functions implementing the EVP ciphers @api{}.

@item vicare crypto openssl message-digests
@cindex Library @library{vicare crypto openssl message-digests}
@cindex @library{vicare crypto openssl message-digests}, library
It exports bindings for some @value{FOREIGN_PACKAGE} low--level
functions implementing message digests.

@item vicare crypto openssl hmac
@cindex Library @library{vicare crypto openssl hmac}
@cindex @library{vicare crypto openssl hmac}, library
It exports bindings for some @value{FOREIGN_PACKAGE} low--level
functions implementing HMAC.

@item vicare crypto openssl aes
@cindex Library @library{vicare crypto openssl aes}
@cindex @library{vicare crypto openssl aes}, library
It exports bindings for some @value{FOREIGN_PACKAGE} low--level
functions implementing the AES cipher.

@item vicare crypto openssl unsafe-capi
@cindex Library @library{vicare crypto openssl unsafe-capi}
@cindex @library{vicare crypto openssl unsafe-capi}, library
It exports syntax bindings for some @value{FOREIGN_PACKAGE} public
functions.  These syntaxes expand to a direct call to the C language
wrapper functions in the @value{PACKAGE} library; they are not meant to
be called in normal usage of the package.

@item vicare crypto openssl constants
@cindex Library @library{vicare crypto openssl constants}
@cindex @library{vicare crypto openssl constants}, library
It exports bindings for some constant values defined in the C language
header @file{openssl/ssl.h} and others.

@item vicare crypto openssl features
@cindex Library @library{vicare crypto openssl features}
@cindex @library{vicare crypto openssl features}, library
It exports one identifier syntax binding for each @code{HAVE_} constant
defined by the @command{configure} script, expanding to @true{} or
@false{}.
@end table

Scheme libraries are installed under the directory:

@center @file{$(libdir)/vicare-scheme}

After installation, under the directory:

@center @file{$(libexecdir)/@value{PACKAGE_NICKNAME}}

@noindent
a script @file{compile-all.sps} can be executed to precompile the
installed libraries; for example:

@example
$ sudo vicare \
   --fasl-directory /var/cache/vicare-scheme \
   --compile-dependencies \
      /usr/local/libexec/vicare-openssl/compile-all.sps
@end example

This document contains only a brief description of the functions: refer
to the @value{FOREIGN_PACKAGE}'s documentation for details.

@c page
@node version
@chapter @value{FOREIGN_PACKAGE} version informations


The installed C library follows version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.

The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun vicare-openssl-version-interface-current
@defunx vicare-openssl-version-interface-revision
@defunx vicare-openssl-version-interface-age
Return a fixnum representing a version number.
@end defun


@defun vicare-openssl-version
Return a Scheme string representing the version number.
@end defun

@c page
@node plain
@chapter Plain programming interface


@menu
* plain init::                  Global initialisation functions.
* plain hash::                  Computing hash checksums.
* plain hmac::                  Computing message authentication codes.
* plain crypto::                Low-level cryptographic algorithms.
* plain evp::                   High-level cryptographic functions.
@end menu

@c page
@node plain init
@section Global initialisation functions


The following bindings are exported by the library @library{vicare
crypto openssl}.


@defun ssl-library-init
Initialise the library; return unspecified values.
@manpage{SSL_library_init, SSL_library_init}.
@end defun


@defun openssl-add-all-algorithms-noconf
Perform some initialisation operations.
@manpage{OPENSSL_add_all_algorithms_noconf, OPENSSL_add_all_algorithms_noconf}.
@end defun


@defun openssl-add-all-algorithms-conf
Perform some initialisation operations.
@manpage{OPENSSL_add_all_algorithms_conf, OPENSSL_add_all_algorithms_conf}.
@end defun


@defun openssl-add-all-algorithms
Perform some initialisation operations.
@manpage{OpenSSL_add_all_algorithms, OpenSSL_add_all_algorithms}.
@end defun


@defun openssl-add-all-ciphers
Perform some initialisation operations.
@manpage{OpenSSL_add_all_ciphers, OpenSSL_add_all_ciphers}.
@end defun


@defun openssl-add-all-digests
Perform some initialisation operations.
@manpage{OpenSSL_add_all_digests, OpenSSL_add_all_digests}.
@end defun


@defun ssleay-add-all-algorithms
Perform some initialisation operations.
@manpage{SSLeay_add_all_algorithms, SSLeay_add_all_algorithms}.
@end defun


@defun ssleay-add-all-ciphers
Perform some initialisation operations.
@manpage{SSLeay_add_all_ciphers, SSLeay_add_all_ciphers}.
@end defun


@defun ssleay-add-all-digests
Perform some initialisation operations.
@manpage{SSLeay_add_all_digests, SSLeay_add_all_digests}.
@end defun

@c page
@node plain hash
@section Computing hash checksums


@menu
* plain hash md4::              Computing MD4 hash checksums.
* plain hash md5::              Computing MD5 hash checksums.
* plain hash mdc2::             Computing MDC2 hash checksums.
* plain hash sha1::             Computing SHA1 hash checksums.
* plain hash sha224::           Computing SHA224 hash checksums.
* plain hash sha256::           Computing SHA256 hash checksums.
* plain hash sha384::           Computing SHA384 hash checksums.
* plain hash sha512::           Computing SHA512 hash checksums.
* plain hash ripemd160::        Computing RIPEMD160 hash checksums.
* plain hash whirlpool::        Computing WHIRLPOOL hash checksums.
@end menu

@c page
@node plain hash md4
@subsection Computing MD4 hash checksums


The raw @api{} to compute MD4 checksums is used as follows:

@smallexample
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl message-digests) ssl.))

(ssl.openssl-add-all-digests)

(let ((ctx (ssl.md4-init)))
  (assert (ssl.md4-update ctx "ciao"))
  (ssl.md4-final ctx))
@result{} #vu8(229 95 235 57 89 152 65 126 80 152 248 176 252 4 127 16)

(ssl.md4 "ciao")
@result{} #vu8(229 95 235 57 89 152 65 126 80 152 248 176 252 4 127 16)
@end smallexample

@menu
* plain hash md4 struct::       Hash checksum data structures.
* plain hash md4 api::          Context updating functions.
* plain hash md4 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash md4 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} md4-ctx
@cindex @var{MD4} argument
@cindex Argument @var{MD4}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{MD4_CTX}; it represents an MD4 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{MD4}.

There are two categories of @code{md4-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{md4-ctx} instances returned by @func{md4-init} do own the context.
When instances of this category are garbage collected or when
@func{md4-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp

@c ------------------------------------------------------------

@StructCommonDoc{md4-ctx, MD4, md4-final}
@StructPropertyListDoc{md4-ctx, MD4}
@StructArgumentsValidationDoc{md4-ctx, MD4}

@c page
@node plain hash md4 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun md4-init
Allocate and initialise a new instance of @code{md4-ctx}; if successful
return the struct, else return @false{}.  @manpage{MD4_Init, MD4_Init}
@end defun


@defun md4-final @var{MD4}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{MD4_Final,
MD4_Final}.  It is fine to apply this function multiple times to the
same @var{MD4} argument.
@end defun


@defun md4-update @var{MD4} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{MD4_Update, MD4_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash md4 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun md4 @var{input}
@defunx md4 @var{input} @var{input.len}
Perform a one--step checksum computing the checksum of the given input
data; return a bytevector holding the result.  @manpage{MD4, MD4}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash md5
@subsection Computing MD5 hash checksums


The raw @api{} to compute MD5 checksums is used as follows:

@smallexample
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl message-digests) ssl.))

(ssl.openssl-add-all-digests)

(let ((ctx (ssl.md5-init)))
  (assert (ssl.md5-update ctx "ciao"))
  (ssl.md5-final ctx))
@result{} #vu8(110 107 196 228 157 212 119 235 201 142 244 4 108 6 123 95)

(ssl.md5 "ciao")
@result{} #vu8(110 107 196 228 157 212 119 235 201 142 244 4 108 6 123 95)
@end smallexample

@menu
* plain hash md5 struct::       Hash checksum data structures.
* plain hash md5 api::          Context updating functions.
* plain hash md5 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash md5 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} md5-ctx
@cindex @var{MD5} argument
@cindex Argument @var{MD5}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{MD5_CTX}; it represents an MD5 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{MD5}.

There are two categories of @code{md5-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{md5-ctx} instances returned by @func{md5-init} do own the context.
When instances of this category are garbage collected or when
@func{md5-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp

@c ------------------------------------------------------------

@StructCommonDoc{md5-ctx, MD5, md5-final}
@StructPropertyListDoc{md5-ctx, MD5}
@StructArgumentsValidationDoc{md5-ctx, MD5}

@c page
@node plain hash md5 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun md5-init
Allocate and initialise a new instance of @code{md5-ctx}; if successful
return the struct, else return @false{}.  @manpage{MD5_Init, MD5_Init}
@end defun


@defun md5-final @var{MD5}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{MD5_Final,
MD5_Final}.  It is fine to apply this function multiple times to the
same @var{MD5} argument.
@end defun


@defun md5-update @var{MD5} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{MD5_Update, MD5_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash md5 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun md5 @var{input}
@defunx md5 @var{input} @var{input.len}
Perform a one--step checksum computing the checksum of the given input
data; return a bytevector holding the result.  @manpage{MD5, MD5}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash mdc2
@subsection Computing MDC2 hash checksums


The raw @api{} to compute MDC2 checksums is used as follows:

@smallexample
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl message-digests) ssl.))

(ssl.openssl-add-all-digests)

(let ((ctx (ssl.mdc2-init)))
  (assert (ssl.mdc2-update ctx "ciao"))
  (ssl.mdc2-final ctx))
@result{} #vu8(7 135 111 85 63 136 98 189 26 91 47 77 36 135 251 237)

(ssl.mdc2 "ciao")
@result{} #vu8(7 135 111 85 63 136 98 189 26 91 47 77 36 135 251 237)
@end smallexample

@menu
* plain hash mdc2 struct::       Hash checksum data structures.
* plain hash mdc2 api::          Context updating functions.
* plain hash mdc2 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash mdc2 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} mdc2-ctx
@cindex @var{MDC2} argument
@cindex Argument @var{MDC2}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{MDC2_CTX}; it represents an MDC2 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{MDC2}.

There are two categories of @code{mdc2-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{mdc2-ctx} instances returned by @func{mdc2-init} do own the context.
When instances of this category are garbage collected or when
@func{mdc2-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp

@c ------------------------------------------------------------

@StructCommonDoc{mdc2-ctx, MDC2, mdc2-final}
@StructPropertyListDoc{mdc2-ctx, MDC2}
@StructArgumentsValidationDoc{mdc2-ctx, MDC2}

@c page
@node plain hash mdc2 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun mdc2-init
Allocate and initialise a new instance of @code{mdc2-ctx}; if successful
return the struct, else return @false{}.  @manpage{MDC2_Init, MDC2_Init}
@end defun


@defun mdc2-final @var{MDC2}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{MDC2_Final,
MDC2_Final}.  It is fine to apply this function multiple times to the
same @var{MDC2} argument.
@end defun


@defun mdc2-update @var{MDC2} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{MDC2_Update, MDC2_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash mdc2 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun mdc2 @var{input}
@defunx mdc2 @var{input} @var{input.len}
Perform a one--step checksum computing the checksum of the given input
data; return a bytevector holding the result.  @manpage{MDC2, MDC2}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha1
@subsection Computing SHA1 hash checksums


The raw @api{} to compute SHA1 checksums is used as follows:

@smallexample
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl message-digests) ssl.))

(ssl.openssl-add-all-digests)

(let ((ctx (ssl.sha1-init)))
  (assert (ssl.sha1-update ctx "ciao"))
  (ssl.sha1-final ctx))
@result{} #vu8(30 78 136 138 198 111 141 212 30 0 197 167 172 54 163
     42 153 80 210 113)

(ssl.sha1 "ciao")
@result{} #vu8(30 78 136 138 198 111 141 212 30 0 197 167 172 54 163
     42 153 80 210 113)
@end smallexample

@menu
* plain hash sha1 struct::       Hash checksum data structures.
* plain hash sha1 api::          Context updating functions.
* plain hash sha1 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash sha1 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} sha1-ctx
@cindex @var{SHA1} argument
@cindex Argument @var{SHA1}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{SHA1_CTX}; it represents a SHA1 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{SHA1}.

There are two categories of @code{sha1-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{sha1-ctx} instances returned by @func{sha1-init} do own the
context.  When instances of this category are garbage collected or when
@func{sha1-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp

@c ------------------------------------------------------------

@StructCommonDoc{sha1-ctx, SHA1, sha1-final}
@StructPropertyListDoc{sha1-ctx, SHA1}
@StructArgumentsValidationDoc{sha1-ctx, SHA1}

@c page
@node plain hash sha1 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha1-init
Allocate and initialise a new instance of @code{sha1-ctx}; if successful
return the struct, else return @false{}.  @manpage{SHA1_Init, SHA1_Init}
@end defun


@defun sha1-final @var{SHA1}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{SHA1_Final,
SHA1_Final}.  It is fine to apply this function multiple times to the
same @var{SHA1} argument.
@end defun


@defun sha1-update @var{SHA1} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{SHA1_Update, SHA1_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha1 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha1 @var{input}
@defunx sha1 @var{input} @var{input.len}
Perform a one--step checksum computing the checksum of the given input
data; return a bytevector holding the result.  @manpage{SHA1, SHA1}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha224
@subsection Computing SHA224 hash checksums


The raw @api{} to compute SHA224 checksums is used as follows:

@smallexample
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl message-digests) ssl.))

(ssl.openssl-add-all-digests)

(let ((ctx (ssl.sha224-init)))
  (assert (ssl.sha224-update ctx "ciao"))
  (ssl.sha224-final ctx))
@result{} #vu8(241 177 161 48 51 237 220 63 222 236 192 237 3 189 192
     25 194 88 144 186 144 102 88 173 218 217 254 254)

(ssl.sha224 "ciao")
@result{} #vu8(241 177 161 48 51 237 220 63 222 236 192 237 3 189 192
     25 194 88 144 186 144 102 88 173 218 217 254 254)
@end smallexample

@menu
* plain hash sha224 struct::       Hash checksum data structures.
* plain hash sha224 api::          Context updating functions.
* plain hash sha224 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash sha224 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} sha224-ctx
@cindex @var{SHA224} argument
@cindex Argument @var{SHA224}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{SHA224_CTX}; it represents a SHA224 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{SHA224}.

There are two categories of @code{sha224-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{sha224-ctx} instances returned by @func{sha224-init} do own the
context.  When instances of this category are garbage collected or when
@func{sha224-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp

@c ------------------------------------------------------------

@StructCommonDoc{sha224-ctx, SHA224, sha224-final}
@StructPropertyListDoc{sha224-ctx, SHA224}
@StructArgumentsValidationDoc{sha224-ctx, SHA224}

@c page
@node plain hash sha224 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha224-init
Allocate and initialise a new instance of @code{sha224-ctx}; if successful
return the struct, else return @false{}.  @manpage{SHA224_Init, SHA224_Init}
@end defun


@defun sha224-final @var{SHA224}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{SHA224_Final,
SHA224_Final}.  It is fine to apply this function multiple times to the
same @var{SHA224} argument.
@end defun


@defun sha224-update @var{SHA224} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{SHA224_Update, SHA224_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha224 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha224 @var{input}
@defunx sha224 @var{input} @var{input.len}
Perform a one--step checksum computing the checksum of the given input
data; return a bytevector holding the result.  @manpage{SHA224, SHA224}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha256
@subsection Computing SHA256 hash checksums


The raw @api{} to compute SHA256 checksums is used as follows:

@smallexample
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl message-digests) ssl.))

(ssl.openssl-add-all-digests)

(let ((ctx (ssl.sha256-init)))
  (assert (ssl.sha256-update ctx "ciao"))
  (ssl.sha256-final ctx))
@result{} #vu8(177 51 160 192 233 190 227 190 32 22 61 42 211 29 98 72
    219 41 42 166 220 177 238 8 122 42 165 14 15 199 90 226)

(ssl.sha256 "ciao")
@result{} #vu8(177 51 160 192 233 190 227 190 32 22 61 42 211 29 98 72
    219 41 42 166 220 177 238 8 122 42 165 14 15 199 90 226)
@end smallexample

@menu
* plain hash sha256 struct::       Hash checksum data structures.
* plain hash sha256 api::          Context updating functions.
* plain hash sha256 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash sha256 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} sha256-ctx
@cindex @var{SHA256} argument
@cindex Argument @var{SHA256}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{SHA256_CTX}; it represents a SHA256 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{SHA256}.

There are two categories of @code{sha256-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{sha256-ctx} instances returned by @func{sha256-init} do own the
context.  When instances of this category are garbage collected or when
@func{sha256-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp

@c ------------------------------------------------------------

@StructCommonDoc{sha256-ctx, SHA256, sha256-final}
@StructPropertyListDoc{sha256-ctx, SHA256}
@StructArgumentsValidationDoc{sha256-ctx, SHA256}

@c page
@node plain hash sha256 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha256-init
Allocate and initialise a new instance of @code{sha256-ctx}; if successful
return the struct, else return @false{}.  @manpage{SHA256_Init, SHA256_Init}
@end defun


@defun sha256-final @var{SHA256}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{SHA256_Final,
SHA256_Final}.  It is fine to apply this function multiple times to the
same @var{SHA256} argument.
@end defun


@defun sha256-update @var{SHA256} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{SHA256_Update, SHA256_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha256 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha256 @var{input}
@defunx sha256 @var{input} @var{input.len}
Perform a one--step checksum computing the checksum of the given input
data; return a bytevector holding the result.  @manpage{SHA256, SHA256}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha384
@subsection Computing SHA384 hash checksums


The raw @api{} to compute SHA384 checksums is used as follows:

@smallexample
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl message-digests) ssl.))

(ssl.openssl-add-all-digests)

(let ((ctx (ssl.sha384-init)))
  (assert (ssl.sha384-update ctx "ciao"))
  (ssl.sha384-final ctx))
@result{} #vu8(110 218 79 204 118 133 171 186 67 69 181 195 13 193 56
    133 175 247 53 154 81 209 135 124 124 85 207 48 93 213
    47 198 34 188 209 168 24 58 194 231 199 253 193 252 20
    195 246 133)

(ssl.sha384 "ciao")
@result{} #vu8(110 218 79 204 118 133 171 186 67 69 181 195 13 193 56
    133 175 247 53 154 81 209 135 124 124 85 207 48 93 213
    47 198 34 188 209 168 24 58 194 231 199 253 193 252 20
    195 246 133)
@end smallexample

@menu
* plain hash sha384 struct::       Hash checksum data structures.
* plain hash sha384 api::          Context updating functions.
* plain hash sha384 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash sha384 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} sha384-ctx
@cindex @var{SHA384} argument
@cindex Argument @var{SHA384}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{SHA384_CTX}; it represents a SHA384 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{SHA384}.

There are two categories of @code{sha384-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{sha384-ctx} instances returned by @func{sha384-init} do own the
context.  When instances of this category are garbage collected or when
@func{sha384-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp

@c ------------------------------------------------------------

@StructCommonDoc{sha384-ctx, SHA384, sha384-final}
@StructPropertyListDoc{sha384-ctx, SHA384}
@StructArgumentsValidationDoc{sha384-ctx, SHA384}

@c page
@node plain hash sha384 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha384-init
Allocate and initialise a new instance of @code{sha384-ctx}; if successful
return the struct, else return @false{}.  @manpage{SHA384_Init, SHA384_Init}
@end defun


@defun sha384-final @var{SHA384}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{SHA384_Final,
SHA384_Final}.  It is fine to apply this function multiple times to the
same @var{SHA384} argument.
@end defun


@defun sha384-update @var{SHA384} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{SHA384_Update, SHA384_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha384 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha384 @var{input}
@defunx sha384 @var{input} @var{input.len}
Perform a one--step checksum computing the checksum of the given input
data; return a bytevector holding the result.  @manpage{SHA384, SHA384}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha512
@subsection Computing SHA512 hash checksums


The raw @api{} to compute SHA512 checksums is used as follows:

@smallexample
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl message-digests) ssl.))

(ssl.openssl-add-all-digests)

(let ((ctx (ssl.sha512-init)))
  (assert (ssl.sha512-update ctx "ciao"))
  (ssl.sha512-final ctx))
@result{} #vu8(160 194 153 183 26 158 89 213 235 176 121 23 231 6 1
    163 87 10 161 3 233 154 123 182 90 88 231 128 236 144
    119 177 144 45 29 237 179 27 20 87 190 218 89 95 228
    215 29 119 155 108 169 202 212 118 38 108 192 117 144
    227 29 132 178 6)

(ssl.sha512 "ciao")
@result{} #vu8(160 194 153 183 26 158 89 213 235 176 121 23 231 6 1
    163 87 10 161 3 233 154 123 182 90 88 231 128 236 144
    119 177 144 45 29 237 179 27 20 87 190 218 89 95 228
    215 29 119 155 108 169 202 212 118 38 108 192 117 144
    227 29 132 178 6)
@end smallexample

@menu
* plain hash sha512 struct::       Hash checksum data structures.
* plain hash sha512 api::          Context updating functions.
* plain hash sha512 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash sha512 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} sha512-ctx
@cindex @var{SHA512} argument
@cindex Argument @var{SHA512}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{SHA512_CTX}; it represents a SHA512 hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{SHA512}.

There are two categories of @code{sha512-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{sha512-ctx} instances returned by @func{sha512-init} do own the
context.  When instances of this category are garbage collected or when
@func{sha512-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp

@c ------------------------------------------------------------

@StructCommonDoc{sha512-ctx, SHA512, sha512-final}
@StructPropertyListDoc{sha512-ctx, SHA512}
@StructArgumentsValidationDoc{sha512-ctx, SHA512}

@c page
@node plain hash sha512 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha512-init
Allocate and initialise a new instance of @code{sha512-ctx}; if successful
return the struct, else return @false{}.  @manpage{SHA512_Init, SHA512_Init}
@end defun


@defun sha512-final @var{SHA512}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{SHA512_Final,
SHA512_Final}.  It is fine to apply this function multiple times to the
same @var{SHA512} argument.
@end defun


@defun sha512-update @var{SHA512} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{SHA512_Update, SHA512_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash sha512 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun sha512 @var{input}
@defunx sha512 @var{input} @var{input.len}
Perform a one--step checksum computing the checksum of the given input
data; return a bytevector holding the result.  @manpage{SHA512, SHA512}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash ripemd160
@subsection Computing RIPEMD160 hash checksums


The raw @api{} to compute RIPEMD160 checksums is used as follows:

@smallexample
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl message-digests) ssl.))

(ssl.openssl-add-all-digests)

(let ((ctx (ssl.ripemd160-init)))
  (assert (ssl.ripemd160-update ctx "ciao"))
  (ssl.ripemd160-final ctx))
@result{} #vu8(73 78 219 37 115 168 139 92 233 100 122
    73 155 77 18 242 144 169 250 190)

(ssl.ripemd160 "ciao")
@result{} #vu8(73 78 219 37 115 168 139 92 233 100 122
    73 155 77 18 242 144 169 250 190)
@end smallexample

@menu
* plain hash ripemd160 struct::       Hash checksum data structures.
* plain hash ripemd160 api::          Context updating functions.
* plain hash ripemd160 direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash ripemd160 struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} ripemd160-ctx
@cindex @var{RIPEMD160} argument
@cindex Argument @var{RIPEMD160}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{RIPEMD160_CTX}; it represents a RIPEMD160 hash
checksum context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{RIPEMD160}.

There are two categories of @code{ripemd160-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{ripemd160-ctx} instances returned by @func{ripemd160-init} do own
the context.  When instances of this category are garbage collected or
when @func{ripemd160-final} is applied to them: the context is closed,
all the associated data is finalised; any error is ignored in this
procedure.
@end itemize
@end deftp

@c ------------------------------------------------------------

@StructCommonDoc{ripemd160-ctx, RIPEMD160, ripemd160-final}
@StructPropertyListDoc{ripemd160-ctx, RIPEMD160}
@StructArgumentsValidationDoc{ripemd160-ctx, RIPEMD160}

@c page
@node plain hash ripemd160 api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun ripemd160-init
Allocate and initialise a new instance of @code{ripemd160-ctx}; if successful
return the struct, else return @false{}.  @manpage{RIPEMD160_Init, RIPEMD160_Init}
@end defun


@defun ripemd160-final @var{RIPEMD160}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{RIPEMD160_Final,
RIPEMD160_Final}.  It is fine to apply this function multiple times to the
same @var{RIPEMD160} argument.
@end defun


@defun ripemd160-update @var{RIPEMD160} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{RIPEMD160_Update, RIPEMD160_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash ripemd160 direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun ripemd160 @var{input}
@defunx ripemd160 @var{input} @var{input.len}
Perform a one--step checksum computing the checksum of the given input
data; return a bytevector holding the result.  @manpage{RIPEMD160,
RIPEMD160}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash whirlpool
@subsection Computing WHIRLPOOL hash checksums


The raw @api{} to compute WHIRLPOOL checksums is used as follows:

@smallexample
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl message-digests) ssl.))

(ssl.openssl-add-all-digests)

(let ((ctx (ssl.whirlpool-init)))
  (assert (ssl.whirlpool-update ctx "ciao"))
  (ssl.whirlpool-final ctx))
@result{} #vu8(152 106 126 88 185 42 0 166 63 74 143 200 89 163 3 73
    252 24 173 157 214 90 15 140 193 41 96 233 221 94 42
    180 241 235 84 108 60 85 85 110 6 1 84 141 34 68 60 230
    208 104 203 49 17 139 135 81 125 206 42 25 173 36 243
    237)

(ssl.whirlpool "ciao")
@result{} #vu8(152 106 126 88 185 42 0 166 63 74 143 200 89 163 3 73
    252 24 173 157 214 90 15 140 193 41 96 233 221 94 42
    180 241 235 84 108 60 85 85 110 6 1 84 141 34 68 60 230
    208 104 203 49 17 139 135 81 125 206 42 25 173 36 243
    237)
@end smallexample

@menu
* plain hash whirlpool struct::       Hash checksum data structures.
* plain hash whirlpool api::          Context updating functions.
* plain hash whirlpool direct::       Directly computing hash checksums.
@end menu

@c page
@node plain hash whirlpool struct
@subsubsection Hash checksum data structures


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@deftp {Struct Type} whirlpool-ctx
@cindex @var{WHIRLPOOL} argument
@cindex Argument @var{WHIRLPOOL}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{WHIRLPOOL_CTX}; it represents a WHIRLPOOL hash
checksum context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{WHIRLPOOL}.

There are two categories of @code{whirlpool-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{whirlpool-ctx} instances returned by @func{whirlpool-init} do own
the context.  When instances of this category are garbage collected or
when @func{whirlpool-final} is applied to them: the context is closed,
all the associated data is finalised; any error is ignored in this
procedure.
@end itemize
@end deftp

@c ------------------------------------------------------------

@StructCommonDoc{whirlpool-ctx, WHIRLPOOL, whirlpool-final}
@StructPropertyListDoc{whirlpool-ctx, WHIRLPOOL}
@StructArgumentsValidationDoc{whirlpool-ctx, WHIRLPOOL}

@c page
@node plain hash whirlpool api
@subsubsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun whirlpool-init
Allocate and initialise a new instance of @code{whirlpool-ctx}; if successful
return the struct, else return @false{}.  @manpage{WHIRLPOOL_Init, WHIRLPOOL_Init}
@end defun


@defun whirlpool-final @var{WHIRLPOOL}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  @manpage{WHIRLPOOL_Final,
WHIRLPOOL_Final}.  It is fine to apply this function multiple times to the
same @var{WHIRLPOOL} argument.
@end defun


@defun whirlpool-update @var{WHIRLPOOL} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{WHIRLPOOL_Update, WHIRLPOOL_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hash whirlpool direct
@subsubsection Directly computing hash checksums


The following bindings are exported by the library @library{vicare
crypto openssl message-digests}.


@defun whirlpool @var{input}
@defunx whirlpool @var{input} @var{input.len}
Perform a one--step checksum computing the checksum of the given input
data; return a bytevector holding the result.  @manpage{WHIRLPOOL,
WHIRLPOOL}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain hmac
@section Computing message authentication codes


The raw @api{} to compute HMAC checksums is used as follows:

@smallexample
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl message-digests) ssl.))

(ssl.openssl-add-all-digests)

(let ((ctx (ssl.hmac-init "key" #f 'md5)))
  (assert (ssl.hmac-update ctx "ciao"))
  (ssl.hmac-final ctx))
@result{} #vu8(104 95 146 126 133 66 104 215 19 225
    230 101 126 75 39 188)

(let ((ctx (ssl.hmac-init "key" #f (ssl.evp-md5))))
  (assert (ssl.hmac-update ctx "ciao"))
  (ssl.hmac-final ctx))
@result{} #vu8(104 95 146 126 133 66 104 215 19 225
    230 101 126 75 39 188)

(ssl.hmac 'md5 "key" #f "ciao" #f)
@result{} #vu8(104 95 146 126 133 66 104 215 19 225
    230 101 126 75 39 188)
@end smallexample

@menu
* plain hmac struct::           HMAC data structures.
* plain hmac api::              Context updating functions.
* plain hmac direct::           Directly computing HMACs.
@end menu

@c page
@node plain hmac struct
@subsection HMAC data structures


The following bindings are exported by the library @library{vicare
crypto openssl hmac}.


@deftp {Struct Type} hmac-ctx
@cindex @var{HMAC} argument
@cindex Argument @var{HMAC}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{HMAC_CTX}; it represents a HMAC hash checksum
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{HMAC}.

There are two categories of @code{hmac-ctx} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{hmac-ctx} instances returned by @func{hmac-init} do own the
context.  When instances of this category are garbage collected or when
@func{hmac-final} is applied to them: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp

@c ------------------------------------------------------------

@StructCommonDoc{hmac-ctx, HMAC, hmac-final}
@StructPropertyListDoc{hmac-ctx, HMAC}
@StructArgumentsValidationDoc{hmac-ctx, HMAC}

@c page
@node plain hmac api
@subsection Context updating functions


The following bindings are exported by the library @library{vicare
crypto openssl}.


@defun hmac-init @var{key} @var{key.len} @var{md}
Allocate and initialise a new instance of @code{hmac-ctx}; if successful
return the struct, else return @false{}.  Notice that this Scheme
function performs the work of both @cfunc{HMAC_CTX_init} and
@cfunc{HMAC_Init}.  @manpage{HMAC_Init, HMAC_Init}.

@var{key} and @var{key.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.

@var{md} must be either a symbol among:

@example
md4             md5             mdc2
sha1            sha224          sha256
sha384          sha512          ripemd160
whirlpool       dss             dss1
@end example

@noindent
or an instance of @code{evp-md} (@pxref{plain evp md algo makers,
Algorithm reference makers})
@end defun


@defun hmac-final @var{HMAC}
Finalise a checksum context; if successful return a bytevector holding
the computed checksum, else return @false{}.  Notice that this Scheme
function performs the work of both @cfunc{HMAC_CTX_cleanup} and
@cfunc{HMAC_Final}.  @manpage{HMAC_Final, HMAC_Final}.  It is fine to
apply this function multiple times to the same @var{HMAC} argument.
@end defun


@defun hmac-update @var{HMAC} @var{input} @var{input.len}
Update the checksum context with the given input data.
@manpage{HMAC_Update, HMAC_Update}

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun


@defun hmac-ctx-copy @var{DST-HMAC} @var{SRC-HMAC}
Duplicate an HMAC context from @var{SRC-HMAC} to @var{DST-HMAC}; if
successful return true, else return @false{}.  @manpage{HMAC_CTX_copy,
HMAC_CTX_copy}.
@end defun


@defun hmac-ctx-set-flags @var{HMAC} @var{flags}
Set flags in an HMAC context; return unspecified values.
@manpage{HMAC_CTX_copy, HMAC_CTX_copy}.
@end defun

@c page
@node plain hmac direct
@subsection Directly computing HMACs


The following bindings are exported by the library @library{vicare
crypto openssl hmac}.


@defun hmac @var{md} @var{key} @var{key.len} @var{input} @var{input.len}
Perform a one--step HMAC computing; return a bytevector holding the
result, or @false{} if an error occurs.  @manpage{HMAC, HMAC}.

@var{md} must be either a symbol among:

@example
md4             md5             mdc2
sha1            sha224          sha256
sha384          sha512          ripemd160
whirlpool       dss             dss1
@end example

@noindent
or an instance of @code{evp-md} (@pxref{plain evp md algo makers,
Algorithm reference makers})

@var{key} and @var{key.len} must represent a generalised C string,
@cstringsref{}.  When @var{key} is a string: it is converted to a
bytevector with @func{string->utf8}.

@var{input} and @var{input.len} must represent a generalised C string,
@cstringsref{}.  When @var{input} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain crypto
@section Low--level cryptographic algorithms.


@menu
* plain crypto aes::            The AES algorithm.
@end menu

@c page
@node plain crypto aes
@subsection The AES algorithm


The cryptographic algorithm AES operates on blocks of size @math{16}.

@menu
* plain crypto aes struct::     Context data structure.
* plain crypto aes key::        Selecting the key.
* plain crypto aes crypt::      Encryption and decryption.
* plain crypto aes misc::       Miscellaneous functions and syntaxes.
@end menu

@c page
@node plain crypto aes struct
@subsubsection Context data structure


The following bindings are exported by the library @library{vicare
crypto openssl aes}.


@deftp {Struct Type} aes-key
@cindex @var{AES} argument
@cindex Argument @var{AES}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{AES_KEY}; it references an AES encryption or
decryption key.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{AES}.

There are two categories of @code{aes-key} instances: those who own the
underlying checksum context and those who merely reference it.

@itemize
@item
@code{aes-key} instances returned by @func{aes-set-encrypt-key} and
@func{aes-set-decrypt-key} do own the context.  When instances of this
category are garbage collected: the context is closed, all the
associated data is finalised; any error is ignored in this procedure.
@end itemize
@end deftp


@defun aes-key? @var{obj}
Return @true{} if @var{obj} is an instance of @code{aes-key}; otherwise
return @false{}.
@end defun


@defun aes-key?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{aes-key} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun aes-key-custom-destructor @var{AES}
@defunx set-aes-key-custom-destructor! @var{AES} @var{func}
Retrieve or set a destructor function associated to the @var{AES}.

Whenever the @var{AES} is closed: @var{func} is applied to @var{AES}
before the internal state of @var{AES} is finalised.
@end defun

@c ------------------------------------------------------------

@StructPropertyListDoc{aes-key-ctx, AES}
@StructArgumentsValidationDoc{aes-key-ctx, AES}

@c page
@node plain crypto aes key
@subsubsection Selecting the key


The following bindings are exported by the library @library{vicare
crypto openssl aes}.


@defun aes-set-encrypt-key @var{key} @var{key.len}
Build an instance of @code{aes-ctx} initialised with the encryption
@var{key}; if successful return the struct, else return @false{}.

@var{key} and @var{key.len} must represent a generalised C string,
@cstringsref{}.  When @var{key} is a string: it is converted to a
bytevector with @func{string->ascii}.  The key length, measured in
bytes, must be: @math{16}, @math{24} or @math{32}; corresponding to a
length measured in bits of: @math{128}, @math{192}, @math{256}.
@end defun


@defun aes-set-decrypt-key @var{key} @var{key.len}
Build an instance of @code{aes-ctx} initialised with the decryption
@var{key}; if successful return the struct, else return @false{}.

@var{key} and @var{key.len} must represent a generalised C string,
@cstringsref{}.  When @var{key} is a string: it is converted to a
bytevector with @func{string->ascii}.  The key length, measured in
bytes, must be: @math{16}, @math{24} or @math{32}; corresponding to a
length measured in bits of: @math{128}, @math{192}, @math{256}.
@end defun

@c page
@node plain crypto aes crypt
@subsubsection Encryption and decryption


The following bindings are exported by the library @library{vicare
crypto openssl aes}.


@defun aes-encrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES}
@defunx aes-decrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES}
Encrypt or decrypt the single data block @var{in} and store the result
in @var{ou}; return unspecified values.

@var{in}, @var{in.len} and @var{ou}, @var{ou.len} must represent
generalised C buffers, @cbuffersref{}.  Their length must be equal to
@code{AES_BLOCK_SIZE} (@math{16}).  @var{in} and @var{ou} can overlap
and also be the same argument.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl aes) ssl.)
  (prefix (vicare crypto openssl constants) ssl.)

(define key.en (ssl.aes-set-encrypt-key "0123456789012345"))
(define key.de (ssl.aes-set-decrypt-key "0123456789012345"))

(define data.in (make-bytevector ssl.AES_BLOCK_SIZE 123))
(define data.en (make-bytevector ssl.AES_BLOCK_SIZE 0))
(define data.de (make-bytevector ssl.AES_BLOCK_SIZE 0))

(ssl.aes-encrypt data.in #f data.en #f key.en)
(ssl.aes-decrypt data.en #f data.de #f key.de)

data.in @result{} #vu8(123 123 123 123 123 123
   123 123 123 123 123 123 123 123 123 123)

data.en @result{} #vu8(204 84 141 21 154 178 104
   243 186 57 101 209 29 113 127 2)

data.de @result{} #vu8(123 123 123 123 123 123
   123 123 123 123 123 123 123 123 123 123)
@end example
@end defun


@defun aes-ecb-encrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES}
@defunx aes-ecb-decrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES}
Encrypt or decrypt the single data block @var{in}, using the ECB scheme,
and store the result in @var{ou}; return unspecified values.

@var{in}, @var{in.len} and @var{ou}, @var{ou.len} must represent
generalised C buffers, @cbuffersref{}.  Their length must be equal to
@code{AES_BLOCK_SIZE} (@math{16}).  @var{in} and @var{ou} can overlap
and also be the same argument.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl aes) ssl.)
  (prefix (vicare crypto openssl constants) ssl.)

(define key.en (ssl.aes-set-encrypt-key "0123456789012345"))
(define key.de (ssl.aes-set-decrypt-key "0123456789012345"))

(define data.in (make-bytevector ssl.AES_BLOCK_SIZE 123))
(define data.en (make-bytevector ssl.AES_BLOCK_SIZE 0))
(define data.de (make-bytevector ssl.AES_BLOCK_SIZE 0))

(ssl.aes-ecb-encrypt data.in #f data.en #f key.en)
(ssl.aes-ecb-decrypt data.en #f data.de #f key.de)
@end example
@end defun


@defun aes-cbc-encrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES} @var{iv} @var{iv.len}
@defunx aes-cbc-decrypt @var{in} @var{in.len} @var{ou} @var{ou.len} @var{AES} @var{iv} @var{iv.len}
Encrypt or decrypt multiple data blocks @var{in}, using the CBC scheme,
and store the result in @var{ou}; return unspecified values.

@var{in}, @var{in.len} and @var{ou}, @var{ou.len} must represent
generalised C buffers, @cbuffersref{}.  Their length must be an exact
multiple of @code{AES_BLOCK_SIZE} (@math{16}).  @var{in} and @var{ou}
can overlap and also be the same argument.

@var{iv} and @var{iv.len} must represent a generalised C buffer holding
the initialisation vector, @cbuffersref{}.  Its length must be equal to
@code{AES_BLOCK_SIZE}.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl aes) ssl.)
  (prefix (vicare crypto openssl constants) ssl.)

(define key.en (ssl.aes-set-encrypt-key "0123456789012345"))
(define key.de (ssl.aes-set-decrypt-key "0123456789012345"))

(define iv (make-bytevector ssl.AES_BLOCK_SIZE 99))

(define data.len (* 5 ssl.AES_BLOCK_SIZE))
(define data.in (make-bytevector data.len 123))
(define data.en (make-bytevector data.len 0))
(define data.de (make-bytevector data.len 0))

(ssl.aes-cbc-encrypt data.in #f data.en #f key.en iv #f)
(ssl.aes-cbc-decrypt data.en #f data.de #f key.de iv #f)
@end example
@end defun

@c page
@node plain crypto aes misc
@subsubsection Miscellaneous functions and syntaxes


The following bindings are exported by the library @library{vicare
crypto openssl aes}.


@defun aes-options
If successful return a string representing some kind of options,
otherwise raise an @condition{error} condition.
@end defun


@defun aes-block-len? @var{obj}
Return @true{} if @var{obj} is a fixnum equal to the AES block size;
otherwise return @false{}.
@end defun


@defun aes-data-len? @var{obj}
Return @true{} if @var{obj} is a fixnum equal to an exact multiple of
the AES block size; otherwise return @false{}.
@end defun


@defun aes-key-len? @var{obj}
Return @true{} if @var{obj} is a fixnum representing a valid AES key
length; valid values are: @math{16}, @math{24}, @math{32}.  Otherwise
return @false{}.
@end defun


@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} aes-block-len @var{buf} @var{buf.len}
@var{buf} and @var{buf.len} must represent a generalised C buffer,
@cbuffersref{}.  Succeed if the length of the buffer equals the AES
block size.
@end deffn


@deffn {Validation Clause} aes-data-len @var{buf} @var{buf.len}
@var{buf} and @var{buf.len} must represent a generalised C buffer,
@cbuffersref{}.  Succeed if the length of the buffer is an exact
multiple of the AES block size.
@end deffn


@deffn {Validation Clause} aes-key-len @var{obj}
Succeed if @var{obj} is a finxum representing a valid AES key length;
valid values are: @math{16}, @math{24}, @math{32}.
@end deffn

@c page
@node plain evp
@section High--level cryptographic functions


@menu
* plain evp md algo::           Message digest algorithms.
* plain evp md ctx::            Message digest generation.
* plain evp cipher algo::       Cipher algorithms.
* plain evp cipher ctx::        Encryption and decription contexts.
* plain evp symbols::           Constants to symbols.
@end menu

@c page
@node plain evp md algo
@subsection Message digest algorithms


@menu
* plain evp md algo struct::    Algorithm data structure.
* plain evp md algo makers::    Algorithm reference makers.
* plain evp md algo inspect::   Algorithm inspection.
* plain evp md algo step::      Single-step message digest.
@end menu

@c page
@node plain evp md algo struct
@subsubsection Algorithm data structure


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@deftp {Struct Type} evp-md
@cindex @var{EVP-MD} argument
@cindex Argument @var{EVP-MD}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{EVP_MD}; it represents a message digest algorithm.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{EVP-MD}.

@code{evp-md} instances are just references to algorithm
implementations, they do not have associated dynamic data; their
finalisation can be left to the garbage collector.
@end deftp


@defun evp-md? @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-md}; otherwise
return @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} evp-md @var{obj}
@deffnx {Validation Clause} false-or-evp-md @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-md?}; the second
clause also accepts @false{}.
@end deffn

@c page
@node plain evp md algo makers
@subsubsection Algorithm reference makers


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-md-null
Return a struct of type @code{evp-md} representing a null message digest
algorithm.  The generated message digest has zero length.
@manpage{EVP_DigestInit, EVP_md_null}.
@end defun


@defun evp-md2
Return a struct of type @code{evp-md} representing the MD2 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_md2}.
@end defun


@defun evp-md4
Return a struct of type @code{evp-md} representing the MD4 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_md4}.
@end defun


@defun evp-md5
Return a struct of type @code{evp-md} representing the MD5 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_md5}.
@end defun


@defun evp-sha
Return a struct of type @code{evp-md} representing the SHA message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha}.
@end defun


@defun evp-sha1
Return a struct of type @code{evp-md} representing the SHA1 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha1}.
@end defun


@defun evp-dss
Return a struct of type @code{evp-md} representing the DSS message
digest algorithm.  @manpage{EVP_DigestInit, EVP_dss}.
@end defun


@defun evp-dss1
Return a struct of type @code{evp-md} representing the DSS1 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_dss1}.
@end defun


@defun evp-ecdsa
Return a struct of type @code{evp-md} representing the ECDSA message
digest algorithm.  @manpage{EVP_DigestInit, EVP_ecdsa}.
@end defun


@defun evp-sha224
Return a struct of type @code{evp-md} representing the SHA224 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha224}.
@end defun


@defun evp-sha256
Return a struct of type @code{evp-md} representing the SHA256 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha256}.
@end defun


@defun evp-sha384
Return a struct of type @code{evp-md} representing the SHA384 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha384}.
@end defun


@defun evp-sha512
Return a struct of type @code{evp-md} representing the SHA512 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_sha512}.
@end defun


@defun evp-mdc2
Return a struct of type @code{evp-md} representing the MDC2 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_mdc2}.
@end defun


@defun evp-ripemd160
Return a struct of type @code{evp-md} representing the RIPEMD160 message
digest algorithm.  @manpage{EVP_DigestInit, EVP_ripemd160}.
@end defun


@defun evp-whirlpool
Return a struct of type @code{evp-md} representing the WHIRLPOOL message
digest algorithm.  @manpage{EVP_DigestInit, EVP_whirlpool}.
@end defun

@c ------------------------------------------------------------

@defun evp-get-digestbyname @var{name}
If successful return a struct of type @code{evp-md} representing the
specified message digest algorithm; otherwise return @false{}.
@manpage{EVP_DigestInit, EVP_get_digestbyname}.

@var{str} must represent a generalised C string holding an @asciiz{}
string, @cstringsref{}.  When @var{str} is a string: it is converted to
a bytevector with @func{string->ascii}.

Examples of valid names: @samp{MD5}, @samp{SHA1}, @samp{SHA224},
@samp{SHA256}, @samp{SHA384}, @samp{SHA512}.
@end defun

@c page
@node plain evp md algo inspect
@subsubsection Algorithm inspection


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-md-name @var{EVP-MD}
Return a string representing the name of the message digest algorithm.
@manpage{EVP_DigestInit, EVP_MD_name}.
@end defun


@defun evp-md-size @var{EVP-MD}
Return an exact integer representing the message digest size produced by
the algorithm specfied by the @code{EVP_MD} structure referenced by the
pointer object @var{EVP-MD-PTR}.  @manpage{EVP_DigestInit, EVP_MD_size}.
@end defun


@defun evp-md-block-size @var{EVP-MD}
Return an exact integer representing the block size produced by the
algorithm specfied by the @code{EVP_MD} structure referenced by the
pointer object @var{EVP-MD-PTR}.  @manpage{EVP_DigestInit,
EVP_MD_block_size}.
@end defun


@defun evp-md-type @var{EVP-MD}
@defunx evp-md-nid @var{EVP-MD}
Return an exact integer representing the NID of the OBJECT IDENTIFIER
representing the given message digest algorithm.
@manpage{EVP_DigestInit, EVP_MD_type}.
@end defun


@defun evp-md-flags @var{EVP-MD}
Return an exact integer representing the flags associated to the given
message digest algorithm.  @manpage{EVP_DigestInit, EVP_MD_flags}.
@end defun


@defun evp-md-pkey-type @var{EVP-MD}
Return an exact integer representing the pkey type (whatever it is) of
the given message digest algorithm.  @manpage{EVP_DigestInit,
EVP_MD_pkey_type}.
@end defun

@c page
@node plain evp md algo step
@subsubsection Single-step message digest


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-digest @var{str} @var{algo}
@defunx evp-digest @var{str} @var{str.len} @var{algo}
Compute a message digest in a single step; if successful return a
bytevector representing the digest, otherwise return @false{}.
@manpage{EVP_DigestInit, EVP_Digest}.

@var{str} and @var{str.len} must represent a generalised C string,
@cstringsref{}.  When @var{str} is a string: it is converted to a
bytevector with @func{string->utf8}.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl evp message-digests) ssl.))

(ssl.openssl-add-all-digests)

(ssl.evp-digest "ciao" (ssl.evp-md5))
@result{} #vu8(110 107 196 228 157 212 119 235 201
    142 244 4 108 6 123 95)

(ssl.evp-digest "ciao" (ssl.evp-md-null))
@result{} #vu8()
@end example
@end defun

@c page
@node plain evp md ctx
@subsection Message digest generation


@menu
* plain evp md ctx examples::   Some message digest usage examples.
* plain evp md ctx struct::     Context data structures.
* plain evp md ctx create::     Context creation and destruction.
* plain evp md ctx init::       Context initialisation and finalisation.
* plain evp md ctx update::     Processing input data.
* plain evp md ctx inspect::    Context inspection.
* plain evp md ctx flags::      Context flags.
@end menu

@c page
@node plain evp md ctx examples
@subsubsection Some message digest usage examples


Here is an example of MD5 checksum computation, notice that the
destruction of the context data structure is left to the garbage
collector:

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl evp message-digests) ssl.))

(ssl.openssl-add-all-algorithms)

(define ctx
  (ssl.evp-md-ctx-create))

(ssl.evp-digest-init ctx 'md5)
(ssl.evp-digest-update ctx "ciao")
(ssl.evp-digest-final ctx)
@result{} #vu8(110 107 196 228 157 212 119
   235 201 142 244 4 108 6 123 95)
@end example

@c page
@node plain evp md ctx struct
@subsubsection Hash checksums data structures


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@deftp {Struct Type} evp-md-ctx
@cindex @var{EVP-MD-CTX} argument
@cindex Argument @var{EVP-MD-CTX}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{EVP_MD_CTX}; it references a message digest context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{EVP-MD-CTX}.

There are two categories of @code{evp-md-ctx} instances: those who own
the underlying checksum context and those who merely reference it.

@itemize
@item
@code{evp-md-ctx} instances returned by @func{evp-md-ctx-create} do own
the context.  When instances of this category are garbage collected: the
context is closed, all the associated data is finalised; any error is
ignored in this procedure.
@end itemize
@end deftp


@defun evp-md-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-md-ctx};
otherwise return @false{}.
@end defun


@defun evp-md-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-md-ctx} and the
context it represents is open; otherwise return @false{}.
@end defun


@defun evp-md-ctx?/running @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-md-ctx} and the
context it represents is open and initialised with
@func{evp-digest-init}; otherwise return @false{}.
@end defun


@defun evp-md-ctx?/alive-not-running @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-md-ctx} and the
context it represents is open but @strong{not} yet initialised with
@func{evp-digest-init}; otherwise return @false{}.
@end defun


@defun evp-md-ctx-custom-destructor @var{EVP-MD-CTX}
@defunx set-evp-md-ctx-custom-destructor! @var{EVP-MD-CTX} @var{func}
Retrieve or set a destructor function associated to the @var{EVP-MD-CTX}.

Whenever the @var{EVP-MD-CTX} is closed: @var{func} is applied to
@var{EVP-MD-CTX} before the internal state of @var{EVP-MD-CTX} is finalised.
@end defun

@c ------------------------------------------------------------

@StructPropertyListDoc{evp-md-ctx, EVP-MD-CTX}

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} evp-md-ctx @var{obj}
@deffnx {Validation Clause} false-or-evp-md-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-md-ctx?}; the
second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} evp-md-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-evp-md-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-md-ctx?/alive};
the second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} evp-md-ctx/running @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-md-ctx?/running}.
@end deffn


@deffn {Validation Clause} evp-md-ctx/alive-not-running @var{obj}
Succeed if @var{obj} satisfies the predicate
@func{evp-md-ctx?/alive-not-running}.
@end deffn

@c page
@node plain evp md ctx create
@subsubsection Context creation and destruction


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-md-ctx-create
Build a new struct of type @code{evp-md-ctx}; if successful return the
data struct, otherwise return @false{}.  Returned data structures are
not yet initialised with a message digest algorithm.
@manpage{EVP_DigestInit, EVP_MD_CTX_create}.
@end defun


@defun evp-md-ctx-destroy @var{EVP-MD-CTX}
Finalise a struct of type @code{evp-md-ctx}, releasing all the
associated resources; return unspecified values.  It is fine to apply
this function multiple times to the same instance of @var{EVP-MD-CTX}.
@manpage{EVP_DigestInit, EVP_MD_CTX_destroy}.
@end defun

@c page
@node plain evp md ctx init
@subsubsection Context initialisation and finalisation


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-digest-init @var{EVP-MD-CTX} @var{md}
Initialise an already built message digest context to produce a hash
checksum of type @var{md}; if successful return @true{}, else return
@false{}.  @manpage{EVP_DigestInit, EVP_DigestInit_ex}.

@var{md} must be an instance of @code{evp-md} or a symbol among:

@example
md4             md5             mdc2
sha1            sha224          sha256
sha384          sha512          ripemd160
whirlpool       dss             dss1
@end example

It is an error to apply this function to an already initialised
@var{EVP-MD-CTX}.
@end defun


@defun evp-digest-final @var{EVP-MD-CTX}
Finalise the generation of a message digest checksum; if succesful
return a bytevector representing the sum, otherwise return @false{}.
@manpage{EVP_DigestInit, EVP_DigestFinal_ex}.

It is an error to apply this function to a non--initialised
@var{EVP-MD-CTX}.
@end defun


@defun evp-md-ctx-copy @var{DST-EVP-MD} @var{SRC-EVP-MD}
Copy a message digest state from @var{SRC-EVP-MD} to @var{DST-EVP-MD};
if successful return @true{}, otherwise return @false{}.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl evp message-digests) ssl.))

(ssl.openssl-add-all-algorithms)

(define src (ssl.evp-md-ctx-create))
(ssl.evp-digest-init src 'md5)
(ssl.evp-digest-update src "ciao")

(define dst (ssl.evp-md-ctx-create))
(ssl.evp-md-ctx-copy dst src)
(ssl.evp-digest-final dst)
@result{} #vu8(110 107 196 228 157 212 119
   235 201 142 244 4 108 6 123 95)
@end example
@end defun

@c page
@node plain evp md ctx update
@subsubsection Processing input data


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-digest-update @var{EVP-MD-CTX} @var{str}
@defunx evp-digest-update @var{EVP-MD-CTX} @var{str} @var{str.len}
Update a message digest context with input data; if successful return
@true{}, otherwise return @false{}.  @manpage{EVP_DigestInit,
EVP_DigestUpdate}.


@var{str} and @var{str.len} must represent a generalised C string,
@cstringsref{}.  When @var{str} is a string: it is converted to a
bytevector with @func{string->utf8}.

It is an error to apply this function to a non--initialised
@var{EVP-MD-CTX}.
@end defun

@c page
@node plain evp md ctx inspect
@subsubsection Context inspection


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-md-ctx-size @var{EVP-MD-CTX}
Return an exact integer representing the message digest size produced by
@var{EVP-MD-CTX}.  @manpage{EVP_DigestInit, EVP_MD_CTX_size}.
@end defun


@defun evp-md-ctx-block-size @var{EVP-MD-CTX}
Return an exact integer representing the block size produced by
@var{EVP-MD-CTX}.  @manpage{EVP_DigestInit, EVP_MD_CTX_block_size}.
@end defun


@defun evp-md-ctx-type @var{EVP-MD-CTX}
Return an exact integer representing the NID of the OBJECT IDENTIFIER
representing the given message digest context.  @manpage{EVP_DigestInit,
EVP_MD_CTX_type}.
@end defun


@defun evp-md-ctx-md @var{EVP-MD-CTX}
If successful return an instance of @code{evp-md} representing the
algorithm with which the context was initialised; otherwise return
@false{}.  @manpage{EVP_DigestInit, EVP_MD_CTX_md}.
@end defun

@c page
@node plain evp md ctx flags
@subsubsection Context flags


The following bindings are exported by the library @library{vicare
crypto openssl evp message-digests}.


@defun evp-md-ctx-set-flags @var{EVP-MD-CTX} @var{flags}
Set the flags for a message digest context.  @manpage{EVP_DigestInit,
EVP_MD_CTX_set_flags}.  Return unspecified values.

@var{flags} must be an exact integer in the range of the C language type
@code{signed int}.
@end defun


@defun evp-md-ctx-clear-flags @var{EVP-MD-CTX} @var{flags}
Clear the flags for a message digest context.  @manpage{EVP_DigestInit,
EVP_MD_CTX_clear_flags}.  Return unspecified values.

@var{flags} must be an exact integer in the range of the C language type
@code{signed int}.
@end defun


@defun evp-md-ctx-test-flags @var{EVP-MD-CTX} @var{flags}
Test the flags for a message digest context.  @manpage{EVP_DigestInit,
EVP_MD_CTX_test_flags}.  Return an exact integer.

@var{flags} must be an exact integer in the range of the C language type
@code{signed int}.
@end defun

@c page
@node plain evp cipher algo
@subsection Cipher algorithms


@menu
* plain evp cipher algo struct::  Cipher algorithms data structures.
* plain evp cipher algo makers::  Algorithm reference makers.
* plain evp cipher algo inspect:: Algorithm inspection.
@end menu

@c page
@node plain evp cipher algo struct
@subsubsection Cipher algorithms data structures


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@deftp {Struct Type} evp-cipher
@cindex @var{EVP-CIPHER} argument
@cindex Argument @var{EVP-CIPHER}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{EVP_CIPHER}; it references an encryption and
decryption algorithm.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{EVP-CIPHER}.

@code{evp-cipher} instances are just references to algorithm
implementations, they do not have associted dynamic data; their
finalisation can be left to the garbage collector.
@end deftp


@defun evp-cipher? @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-cipher};
otherwise return @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} evp-cipher @var{obj}
@deffnx {Validation Clause} false-or-evp-cipher @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-cipher?}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain evp cipher algo makers
@subsubsection Algorithm reference makers


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@macro CipherMakerDefun{WHO}
@defun \WHO\
Build a new struct instance of type @code{evp-cipher}; if successful
return the struct, otherwise return @false{}.
@end defun
@end macro

@CipherMakerDefun{evp-enc-null}
@CipherMakerDefun{evp-des-ecb}
@CipherMakerDefun{evp-des-ede}
@CipherMakerDefun{evp-des-ede3}
@CipherMakerDefun{evp-des-ede-ecb}
@CipherMakerDefun{evp-des-ede3-ecb}
@CipherMakerDefun{evp-des-cfb64}
@CipherMakerDefun{evp-des-cfb}
@CipherMakerDefun{evp-des-ede3-cfb64}
@CipherMakerDefun{evp-des-ede3-cfb}
@CipherMakerDefun{evp-des-ede3-cfb1}
@CipherMakerDefun{evp-des-ede3-cfb8}
@CipherMakerDefun{evp-des-ofb}
@CipherMakerDefun{evp-des-ede-ofb}
@CipherMakerDefun{evp-des-ede3-ofb}
@CipherMakerDefun{evp-des-cbc}
@CipherMakerDefun{evp-des-ede-cbc}
@CipherMakerDefun{evp-des-ede3-cbc}
@CipherMakerDefun{evp-desx-cbc}
@CipherMakerDefun{evp-rc4}
@CipherMakerDefun{evp-rc4-40}
@CipherMakerDefun{evp-rc4-hmac-md5}
@CipherMakerDefun{evp-idea-ecb}
@CipherMakerDefun{evp-idea-cfb64}
@CipherMakerDefun{evp-idea-cfb}
@CipherMakerDefun{evp-idea-ofb}
@CipherMakerDefun{evp-idea-cbc}
@CipherMakerDefun{evp-rc2-ecb}
@CipherMakerDefun{evp-rc2-cbc}
@CipherMakerDefun{evp-rc2-40-cbc}
@CipherMakerDefun{evp-rc2-64-cbc}
@CipherMakerDefun{evp-rc2-cfb64}
@CipherMakerDefun{evp-rc2-cfb}
@CipherMakerDefun{evp-rc2-ofb}

Notice that @code{bf} stands for Blowfish.
@cindex Blowfish cipher.

@CipherMakerDefun{evp-bf-ecb}
@CipherMakerDefun{evp-bf-cbc}
@CipherMakerDefun{evp-bf-cfb64}
@CipherMakerDefun{evp-bf-cfb}
@CipherMakerDefun{evp-bf-ofb}

@CipherMakerDefun{evp-cast5-ecb}
@CipherMakerDefun{evp-cast5-cbc}
@CipherMakerDefun{evp-cast5-cfb64}
@CipherMakerDefun{evp-cast5-cfb}
@CipherMakerDefun{evp-cast5-ofb}
@CipherMakerDefun{evp-rc5-32-12-16-cbc}
@CipherMakerDefun{evp-rc5-32-12-16-ecb}
@CipherMakerDefun{evp-rc5-32-12-16-cfb64}
@CipherMakerDefun{evp-rc5-32-12-16-cfb}
@CipherMakerDefun{evp-rc5-32-12-16-ofb}
@CipherMakerDefun{evp-aes-128-ecb}
@CipherMakerDefun{evp-aes-128-cbc}
@CipherMakerDefun{evp-aes-128-cfb1}
@CipherMakerDefun{evp-aes-128-cfb8}
@CipherMakerDefun{evp-aes-128-cfb128}
@CipherMakerDefun{evp-aes-128-cfb}
@CipherMakerDefun{evp-aes-128-ofb}
@CipherMakerDefun{evp-aes-128-ctr}
@CipherMakerDefun{evp-aes-128-ccm}
@CipherMakerDefun{evp-aes-128-gcm}
@CipherMakerDefun{evp-aes-128-xts}
@CipherMakerDefun{evp-aes-192-ecb}
@CipherMakerDefun{evp-aes-192-cbc}
@CipherMakerDefun{evp-aes-192-cfb1}
@CipherMakerDefun{evp-aes-192-cfb8}
@CipherMakerDefun{evp-aes-192-cfb128}
@CipherMakerDefun{evp-aes-192-cfb}
@CipherMakerDefun{evp-aes-192-ofb}
@CipherMakerDefun{evp-aes-192-ctr}
@CipherMakerDefun{evp-aes-192-ccm}
@CipherMakerDefun{evp-aes-192-gcm}
@CipherMakerDefun{evp-aes-256-ecb}
@CipherMakerDefun{evp-aes-256-cbc}
@CipherMakerDefun{evp-aes-256-cfb1}
@CipherMakerDefun{evp-aes-256-cfb8}
@CipherMakerDefun{evp-aes-256-cfb128}
@CipherMakerDefun{evp-aes-256-cfb}
@CipherMakerDefun{evp-aes-256-ofb}
@CipherMakerDefun{evp-aes-256-ctr}
@CipherMakerDefun{evp-aes-256-ccm}
@CipherMakerDefun{evp-aes-256-gcm}
@CipherMakerDefun{evp-aes-256-xts}
@CipherMakerDefun{evp-aes-128-cbc-hmac-sha1}
@CipherMakerDefun{evp-aes-256-cbc-hmac-sha1}
@CipherMakerDefun{evp-camellia-128-ecb}
@CipherMakerDefun{evp-camellia-128-cbc}
@CipherMakerDefun{evp-camellia-128-cfb1}
@CipherMakerDefun{evp-camellia-128-cfb8}
@CipherMakerDefun{evp-camellia-128-cfb128}
@CipherMakerDefun{evp-camellia-128-cfb}
@CipherMakerDefun{evp-camellia-128-ofb}
@CipherMakerDefun{evp-camellia-192-ecb}
@CipherMakerDefun{evp-camellia-192-cbc}
@CipherMakerDefun{evp-camellia-192-cfb1}
@CipherMakerDefun{evp-camellia-192-cfb8}
@CipherMakerDefun{evp-camellia-192-cfb128}
@CipherMakerDefun{evp-camellia-192-cfb}
@CipherMakerDefun{evp-camellia-192-ofb}
@CipherMakerDefun{evp-camellia-256-ecb}
@CipherMakerDefun{evp-camellia-256-cbc}
@CipherMakerDefun{evp-camellia-256-cfb1}
@CipherMakerDefun{evp-camellia-256-cfb8}
@CipherMakerDefun{evp-camellia-256-cfb128}
@CipherMakerDefun{evp-camellia-256-cfb}
@CipherMakerDefun{evp-camellia-256-ofb}
@CipherMakerDefun{evp-seed-ecb}
@CipherMakerDefun{evp-seed-cbc}
@CipherMakerDefun{evp-seed-cfb128}
@CipherMakerDefun{evp-seed-cfb}
@CipherMakerDefun{evp-seed-ofb}

@c ------------------------------------------------------------

@defun evp-get-cipherbyname @var{name}
Build a new struct instance of type @code{evp-cipher} selecting the
algorithm by its name; if successful return the struct, otherwise return
@false{}.  @manpage{EVP_EncryptInit_ex, EVP_get_cipherbyname}.

@var{name} must represent a generalised C string, @cstringsref{}.  When
@var{str} is a string: it is converted to a bytevector with
@func{string->ascii}.
@end defun


@defun evp-get-cipherbynid @var{nid}
Build a new struct instance of type @code{evp-cipher} selecting the
algorithm by its NID; if successful return the struct, otherwise return
@false{}.  @manpage{EVP_EncryptInit_ex, EVP_get_cipherbynid}.

@var{nid} must be an exact integer, in the range of the C language type
@code{signed int}, representing the NID of a cipher algorithm.  NID
values can be extracted by an @code{evp-cipher} struct using
@func{evp-cipher-nid}.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl evp ciphers) ssl.))

(ssl.openssl-add-all-algorithms)
(ssl.evp-get-cipherbynid 109)
@result{} #[evp-cipher ...]
@end example
@end defun


@ignore
@c Not implemented yet (Marco Maggi; Wed Mar 20, 2013)

@defun evp-get-cipherbyobj @var{ASN-OBJ}
Build a new struct instance of type @code{evp-cipher} selecting the
algorithm by its ASN.1 object; if successful return the struct,
otherwise return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_get_cipherbyobj}.
@end defun
@end ignore

@c page
@node plain evp cipher algo inspect
@subsubsection Algorithm inspection


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-name @var{EVP-CIPHER}
Return a string representing the name of the cipher algorithm.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl evp ciphers) ssl.))

(ssl.openssl-add-all-algorithms)

(ssl.evp-cipher-name (ssl.evp-enc-null))
@result{} "UNDEF"

(ssl.evp-cipher-name (ssl.evp-des-ecb))
@result{} "DES-ECB"

(ssl.evp-cipher-name (ssl.evp-rc4))
@result{} "RC4"

(ssl.evp-cipher-name (ssl.evp-rc2-ecb))
@result{} "RC2-ECB"

(ssl.evp-cipher-name (ssl.evp-cast5-ecb))
@result{} "CAST5-ECB"

(ssl.evp-cipher-name (ssl.evp-camellia-128-ecb))
@result{} "CAMELLIA-128-ECB"
@end example
@end defun


@defun evp-cipher-nid @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the NID of the cipher algorithm.

@example
#!r6rs
(import (vicare)
  (prefix (vicare crypto openssl) ssl.)
  (prefix (vicare crypto openssl evp ciphers) ssl.))

(ssl.openssl-add-all-algorithms)
(ssl.evp-cipher-nid (ssl.evp-cast5-ecb))
@result{} 109
@end example
@end defun


@defun evp-cipher-type @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the type of the cipher algorithm.
@end defun


@defun evp-cipher-block-size @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the block size of the cipher algorithm.
For stream algorithms: the block size is @math{1}.
@end defun


@defun evp-cipher-key-length @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the key length of the cipher algorithm.
@end defun


@defun evp-cipher-iv-length @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the initialisation vector of the cipher
algorithm.  If the algorithm makes no use of initialisation vectors: the
returned value is @math{0}.
@end defun


@defun evp-cipher-mode @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the mode the cipher algorithm.  The
returned value is one of the @code{EVP_CIPH_*_MODE} constants.
@end defun


@defun evp-cipher-flags @var{EVP-CIPHER}
Return an exact integer, in the range of the C language type
@code{signed int}, representing the flags of the cipher algorithm.
@end defun

@c page
@node plain evp cipher ctx
@subsection Encryption and decription contexts


@menu
* plain evp cipher ctx struct::   Cipher context data structures.
* plain evp cipher ctx create::   Context creation and destruction.
* plain evp cipher ctx encrypt::  Encrypting data.
* plain evp cipher ctx decrypt::  Decrypting data.
* plain evp cipher ctx cipher::   Encrypting or decrypting data.
* plain evp cipher ctx inspect::  Context inspection.
* plain evp cipher ctx config::   Context configuration.
* plain evp cipher ctx flags::    Context flags.
* plain evp cipher ctx misc::     Miscellaneous functions.
* plain evp cipher ctx step::     Single-step encryption and decryption.
@end menu

@c page
@node plain evp cipher ctx struct
@subsubsection Cipher context data structures


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@deftp {Struct Type} evp-cipher-ctx
@cindex @var{EVP-CIPHER-CTX} argument
@cindex Argument @var{EVP-CIPHER-CTX}
An opaque Scheme structure holding a pointer object referencing the C
language type @code{EVP_CIPHER_CTX}; it references a message digest
context.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{EVP-CIPHER-CTX}.

There are two categories of @code{evp-cipher-ctx} instances: those who
own the underlying checksum context and those who merely reference it.

@itemize
@item
@code{evp-cipher-ctx} instances returned by @func{evp-cipher-ctx-new} do
own the context.  When instances of this category are garbage collected
or @func{evp-cipher-ctx-free} is applied to them: the context is closed,
all the associated data is finalised; any error is ignored in this
procedure.
@end itemize
@end deftp


@defun evp-cipher-ctx? @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-cipher-ctx};
otherwise return @false{}.
@end defun


@defun evp-cipher-ctx?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-cipher-ctx} and
the context it represents is open; otherwise return @false{}.
@end defun


@defun evp-cipher-ctx?/running @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-cipher-ctx} and
the context it represents is open and initialised with
@func{evp-encrypt-init} or similar functions; otherwise return @false{}.
@end defun


@defun evp-cipher-ctx?/alive-not-running @var{obj}
Return @true{} if @var{obj} is an instance of @code{evp-cipher-ctx} and
the context it represents is open but @strong{not} yet initialised with
@func{evp-encrypt-init} or similar functions; otherwise return @false{}.
@end defun


@defun evp-cipher-ctx-custom-destructor @var{EVP-CIPHER-CTX}
@defunx set-evp-cipher-ctx-custom-destructor! @var{EVP-CIPHER-CTX} @var{func}
Retrieve or set a destructor function associated to the
@var{EVP-CIPHER-CTX}.

Whenever the @var{EVP-CIPHER-CTX} is closed: @var{func} is applied to
@var{EVP-CIPHER-CTX} before the internal state of @var{EVP-CIPHER-CTX}
is finalised.
@end defun

@c ------------------------------------------------------------

@StructPropertyListDoc{evp-cipher-ctx, EVP-CIPHER-CTX}

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} evp-cipher-ctx @var{obj}
@deffnx {Validation Clause} false-or-evp-cipher-ctx @var{obj}
Succeed if @var{obj} satisfies the predicate @func{evp-cipher-ctx?}; the
second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} evp-cipher-ctx/alive @var{obj}
@deffnx {Validation Clause} false-or-evp-cipher-ctx/alive @var{obj}
Succeed if @var{obj} satisfies the predicate
@func{evp-cipher-ctx?/alive}; the second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} evp-cipher-ctx/running @var{obj}
Succeed if @var{obj} satisfies the predicate
@func{evp-cipher-ctx?/running}.
@end deffn


@deffn {Validation Clause} evp-cipher-ctx/alive-not-running @var{obj}
Succeed if @var{obj} satisfies the predicate
@func{evp-cipher-ctx?/alive-not-running}.
@end deffn

@c page
@node plain evp cipher ctx create
@subsubsection Context creation and destruction


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-ctx-new
Build a new instance of @code{evp-cipher-ctx}; if successful return the
struct instance, else return @false{}.  Returned data structures are not
yet initialised with a cipher algorithm.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_new}.
@end defun


@defun evp-cipher-ctx-free @var{EVP-CIPHER-CTX}
Finalise a cipher context and release all the associated resources;
return unspecified values.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_free}.

It is fine to apply this function multiple times to the same argument:
the first time the context is finalised, subsequent times nothing
happens.
@end defun

@c page
@node plain evp cipher ctx encrypt
@subsubsection Encrypting data


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-encrypt-init @var{EVP-CIPHER-CTX} @var{EVP-CIPHER} @var{key} @var{iv}
Initialise an already built cipher context to encrypt data with the
algorithm selected by @var{EVP-CIPHER}; if successful return @true{},
else return @false{}.  @manpage{EVP_EncryptInit_ex, EVP_EncryptInit_ex}.

@var{key} must be @false{} or represent a generalised C string holding
the encryption key, @cstringsref{}.  When @var{key} is a string: it is
converted to a bytevector with @func{string->utf8}.

@var{iv} must be @false{} or represent a generalised C string holding
the initialisation vector, @cstringsref{}.  When @var{iv} is a string:
it is converted to a bytevector with @func{string->utf8}.
@end defun


@defun evp-encrypt-final @var{EVP-CIPHER-CTX}
Finalise an encryption context; if successful return a bytevector
holding the last output data, else return @false{}.
@manpage{EVP_EncryptInit_ex, EVP_EncryptFinal_ex}.
@end defun


@defun evp-encrypt-update @var{EVP-CIPHER-CTX} @var{ou} @var{ou_len} @var{in} @var{in_len}
Update an encryption context with clear text input data and produce
encrypted output data; if successful return the actual number of bytes
in the output, else return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_EncryptUpdate}.

The arguments @var{in} and @var{in_len} must represent a generalised C
string holding the clear text input data, @cstringsref{}.  When @var{in}
is a string: it is converted to a bytevector with @func{string->utf8}.

The arguments @var{ou} and @var{ou_len} must represent a generalised C
buffer holding empty room for the encrypted output data, @cbuffersref{}.
The length of the output buffer is the maximum number of output bytes
that can be accepted; such length must be:

@enumerate
@item
Less than the greatest fixnum, @code{(greatest-fixnum)}.

@item
Less than the value of @code{INT_MAX} defined by the underlying
platform.

@item
At least the sum between the number of input bytes and the block size of
the selected cipher algorithm.
@end enumerate

The minimum output length can be computed with
@func{evp-minimum-output-length}.
@end defun

@c page
@node plain evp cipher ctx decrypt
@subsubsection Decrypting data


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-decrypt-init @var{EVP-CIPHER-CTX} @var{EVP-CIPHER} @var{key} @var{iv}
Initialise an already built cipher context to decrypt data with the
algorithm selected by @var{EVP-CIPHER}; if successful return @true{},
else return @false{}.  @manpage{EVP_EncryptInit_ex, EVP_DecryptInit_ex}.

@var{key} must be @false{} or represent a generalised C string holding
the decryption key, @cstringsref{}.  When @var{key} is a string: it is
converted to a bytevector with @func{string->utf8}.

@var{iv} must be @false{} or represent a generalised C string holding
the initialisation vector, @cstringsref{}.  When @var{iv} is a string:
it is converted to a bytevector with @func{string->utf8}.
@end defun


@defun evp-decrypt-final @var{EVP-CIPHER-CTX}
Finalise a decryption context; if successful return a bytevector holding
the last output data, else return @false{}.
@manpage{EVP_EncryptInit_ex, EVP_DecryptFinal_ex}.
@end defun


@defun evp-decrypt-update @var{EVP-CIPHER-CTX} @var{ou} @var{ou_len} @var{in} @var{in_len}
Update a decryption context with encrypted text input data and produce
decrypted output data; if successful return the actual number of bytes
in the output, else return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_DecryptUpdate}.

The arguments @var{in} and @var{in_len} must represent a generalised C
buffer holding the encrypted input data, @cbuffersref{}.

The arguments @var{ou} and @var{ou_len} must represent a generalised C
buffer holding empty room for the decrypted output data, @cbuffersref{}.
The length of the output buffer is the maximum number of output bytes
that can be accepted; such length must be:

@enumerate
@item
Less than the greatest fixnum, @code{(greatest-fixnum)}.

@item
Less than the value of @code{INT_MAX} defined by the underlying
platform.

@item
At least the sum between the number of input bytes and the block size of
the selected cipher algorithm.
@end enumerate

The minimum output length can be computed with
@func{evp-minimum-output-length}.
@end defun

@c page
@node plain evp cipher ctx cipher
@subsubsection Encrypting or decrypting data


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-init @var{EVP-CIPHER-CTX} @var{EVP-CIPHER} @var{key} @var{iv} @var{enc}
Initialise an already built cipher context to encrypt or decrypt data
with the algorithm selected by @var{EVP-CIPHER}; if successful return
@true{}, else return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_CipherInit_ex}.

@var{key} must be @false{} or represent a generalised C string holding
the encryption key, @cstringsref{}.  When @var{key} is a string: it is
converted to a bytevector with @func{string->utf8}.

@var{iv} must be @false{} or represent a generalised C string holding
the initialisation vector, @cstringsref{}.  When @var{iv} is a string:
it is converted to a bytevector with @func{string->utf8}.

@var{enc} must be a fixnum: @math{1} for encryption, @math{0} for
decryption, @math{-1} to leave unchanged a previously set value.
@end defun


@defun evp-cipher-final @var{EVP-CIPHER-CTX}
Finalise an encryption or decryption context; if successful return a
bytevector holding the last output data, else return @false{}.
@manpage{EVP_EncryptInit_ex, EVP_CipherFinal_ex}.
@end defun


@defun evp-cipher-update @var{EVP-CIPHER-CTX} @var{ou} @var{ou_len} @var{in} @var{in_len}
Update an encryption or decryption context with input data and produce
output data; if successful return the actual number of bytes in the
output, else return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_CipherUpdate}.

The arguments @var{in} and @var{in_len} must represent a generalised C
string holding the input data, @cstringsref{}.  When @var{in} is a
string: it is converted to a bytevector with @func{string->utf8}.

The arguments @var{ou} and @var{ou_len} must represent a generalised C
buffer holding empty room for the output data, @cbuffersref{}.  The
length of the output buffer is the maximum number of output bytes that
can be accepted; such length must be:

@enumerate
@item
Less than the greatest fixnum, @code{(greatest-fixnum)}.

@item
Less than the value of @code{INT_MAX} defined by the underlying
platform.

@item
At least the sum between the number of input bytes and the block size of
the selected cipher algorithm.
@end enumerate

The minimum output length can be computed with
@func{evp-minimum-output-length}.
@end defun

@c page
@node plain evp cipher ctx inspect
@subsubsection Context inspection


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-ctx-cipher @var{EVP-CIPHER-CTX}
Retrieve the cipher algorithm used by the given context; if successful
return an instance of @code{evp-cipher}, otherwise return @false{}.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_cipher}.
@end defun


@defun evp-cipher-ctx-nid @var{EVP-CIPHER-CTX}
Return an exact integer representing the NID of the cipher algorithm.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_nid}.
@end defun


@defun evp-cipher-ctx-type @var{EVP-CIPHER-CTX}
Return an exact integer representing the type of the cipher algorithm.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_type}.
@end defun


@defun evp-cipher-ctx-block-size @var{EVP-CIPHER-CTX}
Return an exact integer representing the block size of the cipher
algorithm.  @manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_block_size}.
@end defun


@defun evp-cipher-ctx-key-length @var{EVP-CIPHER-CTX}
Return an exact integer representing the key length of the cipher
algorithm.  @manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_key_length}.
@end defun


@defun evp-cipher-ctx-iv-length @var{EVP-CIPHER-CTX}
Return an exact integer representing the initialisation vecttor length
of the cipher algorithm.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_iv_length}.
@end defun


@defun evp-cipher-ctx-mode @var{EVP-CIPHER-CTX}
Return an exact integer representing the mode of the cipher algorithm,
one of the @code{EVP_CIPH_*_MODE} constants.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_mode}.
@end defun

@c page
@node plain evp cipher ctx config
@subsubsection Context configuration


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-ctx-set-key-length @var{EVP-CIPHER-CTX} @var{key.len}
Set the key length to use among the supported values; if successful
return @true{}, otherwise return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_set_key_length}.

@var{key.len} must be an exact integer representing the key length.
@end defun


@defun evp-cipher-ctx-set-padding @var{EVP-CIPHER-CTX} @var{pad?}
Enable or disable padding; if successful return @true{}, otherwise
return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_set_padding}.

If @var{pad?} is true: padding is enabled.  If @var{pad?} is @false{}:
padding is disabled.
@end defun


@defun evp-cipher-ctx-ctrl @var{EVP-CIPHER-CTX} @var{type}
@defunx evp-cipher-ctx-ctrl @var{EVP-CIPHER-CTX} @var{type} @var{arg}
Set or retrieve some context parameters.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_set_key_ctrl}.

When the argument @var{arg} @strong{is not} used, @var{type} must be one
of the following:

@table @code
@item EVP_CTRL_GET_RC5_ROUNDS
Return an exact integer representing the number of rounds for the RC5
algorithm.

@item EVP_CTRL_GET_RC2_KEY_BITS
Return an exact integer representing the number of key bits for the RC2
algorithm.
@end table

When the argument @var{arg} @strong{is} used, @var{type} must be one of
the following:

@table @code
@item EVP_CTRL_SET_RC5_ROUNDS
Set to @var{arg} the number of rounds for the RC5 algorithm; if
successful return @true{}, else return @false{}.

@item EVP_CTRL_SET_RC2_KEY_BITS
Set to @var{arg} the number of key bits for the RC2 algorithm; if
successful return @true{}, else return @false{}.
@end table
@end defun


@defun evp-cipher-ctx-rand-key @var{EVP-CIPHER-CTX} @var{key}
Set a key for the cipher algorithm; if successful return @true{},
otherwise return @false{}.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_rand_key}.

@var{key} must be a generalised C string holding an @asciiz{} string,
@cstringsref{}.  When @var{key} is a string: it is converted to a
bytevector with @func{string->utf8}.
@end defun

@c page
@node plain evp cipher ctx flags
@subsubsection Context flags


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-cipher-ctx-flags @var{EVP-CIPHER-CTX}
Return an exact integer representing the context's flags.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_flags}.
@end defun


@defun evp-cipher-ctx-set-flags @var{EVP-CIPHER-CTX} @var{flags}
Set a context's flags; return unspecified values.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_set_flags}.
@end defun


@defun evp-cipher-ctx-clear-flags @var{EVP-CIPHER-CTX} @var{flags}
Clear a context's flags; return unspecified values.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_clear_flags}.
@end defun


@defun evp-cipher-ctx-test-flags @var{EVP-CIPHER-CTX} @var{flags}
Tests a context's flags; return an exact integer.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_test_flags}.
@end defun

@c page
@node plain evp cipher ctx misc
@subsubsection Miscellaneous functions


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-minimum-output-length @var{EVP-CIPHER-CTX} @var{in} @var{in.len}
Compute the minimum output length needed to encrypt or decrypt the given
argument; if successful return an exact integer representing the number
of bytes, else return @false{}.

The arguments @var{in} and @var{in_len} must represent a generalised C
string holding the clear text input data, @cstringsref{}.  When @var{in}
is a string: it is converted to a bytevector with @func{string->utf8}.
@end defun


@defun evp-cipher-ctx-copy @var{EVP-CIPHER-CTX-DST} @var{EVP-CIPHER-CTX-SRC}
Copy the context from @var{EVP-CIPHER-CTX-SRC} to
@var{EVP-CIPHER-CTX-DST}, which must be already initialised; if
successful return @true{}, otherwise return @false{}.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_copy}.
@end defun

@c ------------------------------------------------------------

@defun evp-cipher-ctx-get-app-data @var{EVP-CIPHER-CTX}
Return @false{} or a pointer previously registered as application data
associated to the given context.  @manpage{EVP_EncryptInit_ex,
EVP_CIPHER_CTX_get_app_data}.
@end defun


@defun evp-cipher-ctx-set-app-data @var{EVP-CIPHER-CTX} @var{data}
Register a pointer as application data associated to the given context.
@manpage{EVP_EncryptInit_ex, EVP_CIPHER_CTX_set_app_data}.

@var{data} must be a pointer object or @false{}; when @var{data} is
@false{}: the @cnull{} pointer is registered.
@end defun

@c ------------------------------------------------------------

@defun evp-cipher-param-to-asn1
not implemented.
@end defun

@defun evp-cipher-asn1-to-param
Not implemented.
@end defun

@c page
@node plain evp cipher ctx step
@subsubsection Single--step encryption and decryption


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-crypt @var{EVP-CIPHER-CTX} @var{ou} @var{ou_len} @var{in} @var{in_len}
Encrypt or decrypt input data and produce output data; if successful it
should return the actual number of bytes in the output, else return
@false{}.  @manpage{EVP_EncryptInit_ex, EVP_Cipher}.

@quotation
@strong{NOTE} This is a low level function not documented by OpenSSL; we
should use it only if we know what we are doing.  For some cipher
algorithms the return value is @strong{not} the number of actual output
bytes.
@end quotation

@var{EVP-CIPHER-CTX} must be a context already initialised for
encryption or decryption.

The arguments @var{in} and @var{in_len} must represent a generalised C
string holding the input data, @cstringsref{}.  When @var{in} is a
string: it is converted to a bytevector with @func{string->utf8}.

The arguments @var{ou} and @var{ou_len} must represent a generalised C
buffer holding empty room for the output data, @cbuffersref{}.  The
length of the output buffer is the maximum number of output bytes that
can be accepted; such length must be:

@enumerate
@item
Less than the greatest fixnum, @code{(greatest-fixnum)}.

@item
Less than the value of @code{INT_MAX} defined by the underlying
platform.

@item
At least the sum between the number of input bytes and the block size of
the selected cipher algorithm.
@end enumerate

The minimum output length can be computed with
@func{evp-minimum-output-length}.
@end defun

@c page
@node plain evp symbols
@subsection Constants to symbols


The following bindings are exported by the library @library{vicare
crypto openssl evp ciphers}.


@defun evp-ciph-mode->symbol @var{constant}
Given a constant among @code{EVP_CIPH_*_MODE} return a symbol
representing its public name.
@end defun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest version of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{SOURCEFORGE_URL}

@noindent
the home page of the Vicare project is at:

@center @url{http://marcomaggi.github.com/vicare.html}

@noindent
the home page of the Nausicaa project is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
@value{FOREIGN_PACKAGE} can be found here:

@center @value{FOREIGN_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

